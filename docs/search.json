[{"path":"https://tony-aw.github.io/subsets/articles/Benchmarks.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Benchmarks","text":"Due many checks conversions performed subsets:: functions, make sub-setting programmatically beginner friendly, functions almost necessarily slower base R’s [-like operators. However, considerable effort made keep speed loss minimum. Generally, speed loss indeed neglible, cases even speed improvement (thanks heavy lifting performed ‘collapse’ pakackage). benchmarks give one idea speed loss. just examples; speed determined great number factors.  ","code":"library(bench) library(ggplot2) library(patchwork)"},{"path":[]},{"path":"https://tony-aw.github.io/subsets/articles/Benchmarks.html","id":"matrix","dir":"Articles","previous_headings":"Atomic objects","what":"Matrix","title":"Benchmarks","text":" ","code":"x.mat <- matrix(seq_len(1000*1000), ncol = 1000) colnames(x.mat) <- sample(c(letters, NA), 1000, TRUE) sel.rows <- 1:100 sel.cols <- rep(sample(letters[1:13]), 10) bm.matrix <- bench::mark(   \"subsets\" = sb_x.matrix(x.mat, sel.rows, sel.cols),   \"base R\" = x.mat[sel.rows, lapply(sel.cols, \\(i) which(colnames(x.mat) == i)) |> unlist(), drop = FALSE],   min_iterations = 1e4 ) summary(bm.matrix, relative = TRUE) #> # A tibble: 2 × 6 #>   expression   min median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <dbl>  <dbl>     <dbl>     <dbl>    <dbl> #> 1 subsets     1      1         1.41      1.09     1.18 #> 2 base R      1.42   1.44      1         1        1"},{"path":"https://tony-aw.github.io/subsets/articles/Benchmarks.html","id":"array-3d","dir":"Articles","previous_headings":"Atomic objects","what":"Array (3D)","title":"Benchmarks","text":" ","code":"x.dims <- c(1000, 900, 4) x.3d <- array(1:prod(x.dims), x.dims) sel.rows <- 1:900 sel.lyrs <- c(TRUE, FALSE, TRUE, FALSE) bm.3d <- bench::mark(   \"subsets\" =  sb_x.array(x.3d, rcl = n(sel.rows, NULL, sel.lyrs)),   \"base R + abind\" = abind::asub(x.3d, idx = list(sel.rows, sel.lyrs), dims = c(1,3)),   min_iterations = 1e4 ) summary(bm.3d, relative = TRUE) #> # A tibble: 2 × 6 #>   expression       min median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <dbl>  <dbl>     <dbl>     <dbl>    <dbl> #> 1 subsets         1      1         1.01      1.00     1.03 #> 2 base R + abind  1.00   1.02      1         1        1"},{"path":"https://tony-aw.github.io/subsets/articles/Benchmarks.html","id":"plot","dir":"Articles","previous_headings":"Atomic objects","what":"Plot","title":"Benchmarks","text":" ","code":"#> Loading required namespace: tidyr"},{"path":[]},{"path":"https://tony-aw.github.io/subsets/articles/Benchmarks.html","id":"data-frame","dir":"Articles","previous_headings":"Data.frame-like objects","what":"data.frame","title":"Benchmarks","text":" ","code":"n <- 1e5 chrmat <- matrix(   sample(letters, n*400, replace = TRUE), ncol = 400 ) intmat <- matrix(   seq.int(n*400), ncol = 400 ) x <- cbind(chrmat, intmat) |> as.data.frame() rm(list = c(\"chrmat\", \"intmat\")) colnames(x) <- make.names(colnames(x), unique = TRUE) sel.cols <- rep(sample(names(x), 10), 4) sel.rows <- 1:1000 bm.df <- bench::mark(   \"subsets\" = sb_x.data.frame(x, sel.rows, sel.cols),   \"collapse::ss\" = collapse::ss(x, sel.rows, match(sel.cols, names(x))),   \"base R\" = x[sel.rows, match(sel.cols, names(x)), drop = FALSE],   min_iterations = 1e4 ) summary(bm.df, relative = TRUE)"},{"path":"https://tony-aw.github.io/subsets/articles/Benchmarks.html","id":"data-table","dir":"Articles","previous_headings":"Data.frame-like objects","what":"data.table","title":"Benchmarks","text":" ","code":"x <- as.data.table(x) tempfun <- function(x, i, j) {   x <- collapse::ss(x, i, j, check = TRUE)   names(x) <- make.names(names(x), unique = TRUE)   return(x) } bm.dt <- bench::mark(   \"subsets\" = sb_x.data.frame(x, sel.rows, sel.cols),   \"data.table + collapse\" = tempfun(x, sel.rows, match(sel.cols, names(x))),   min_iterations = 1e4 ) summary(bm.dt, relative = TRUE) #> # A tibble: 2 × 6 #>   expression              min median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>            <dbl>  <dbl>     <dbl>     <dbl>    <dbl> #> 1 subsets                1.16   1.16      1         1        1    #> 2 data.table + collapse  1      1         1.19      1.02     1.19"},{"path":"https://tony-aw.github.io/subsets/articles/Benchmarks.html","id":"plot-1","dir":"Articles","previous_headings":"Data.frame-like objects","what":"plot","title":"Benchmarks","text":" ","code":""},{"path":"https://tony-aw.github.io/subsets/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Tony Wilkes. Author, maintainer, copyright holder.","code":""},{"path":"https://tony-aw.github.io/subsets/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wilkes T (2023). subsets: Holistic Grammar Subsets. R package version 0.0.0.9.","code":"@Manual{,   title = {subsets: A Holistic Grammar of Subsets},   author = {Tony Wilkes},   year = {2023},   note = {R package version 0.0.0.9}, }"},{"path":"https://tony-aw.github.io/subsets/index.html","id":"subsets","dir":"","previous_headings":"","what":"A Holistic Grammar of Subsets","title":"A Holistic Grammar of Subsets","text":"subsets: Holistic Grammar Subsets  ","code":""},{"path":"https://tony-aw.github.io/subsets/index.html","id":"motivation","dir":"","previous_headings":"","what":"Motivation","title":"A Holistic Grammar of Subsets","text":" ","code":"Among programming languages, 'R' has perhaps one of the most flexible and comprehensive sub-setting functionality. But with flexibility often comes confusion and (apparent) inconsistencies. And 'R' is no exception.  This becomes quite apparent when one reads (online) documents such as \"The R Inferno\" by Patrick Burns, and \"Frustration: One Year With R\" by Reece Goding. These documents point out many inconsistencies, and sub-setting related inconsistencies make up a good portion of these documents.  To my surprise, there is no comprehensive R-package (as far as I could see at least) that actually attempts to \"fix\" the subset-related issues laid out in these and other such documents.  Famous subset-related R packages such as 'dplyr' and 'data.table' focus almost exclusive on data.frame-like objects, and occasionally even add more frustration in some aspects, like being not very programmatically friendly.  Thus, this R package was born.  Although this package was somewhat made for people who are new to 'R' (especially when coming from another programming language), and found themselves confused, I trust this package will be useful even for those who are quite experienced in 'R'."},{"path":"https://tony-aw.github.io/subsets/index.html","id":"goal--properties","dir":"","previous_headings":"","what":"Goal & Properties","title":"A Holistic Grammar of Subsets","text":"Goal ‘subsets’ package replace square-brackets operators ([, [[, [<-, [[<-) per-sé, provide alternative sub-setting methods functions, used situations square-brackets operators inconvenient. (hopefully) easier sub-setting methods functions following properties: Programmatically friendly: Non-standard evaluation quite controversial (good reasons), therefore completely absent R package. Name-based arguments instead position-based arguments. Missing arguments can filled NULL, instead using dark magic like base::quote(expr = ). Functions pipe-friendly. Beginner friendly: (silent) vector recycling. Extracting removing subsets uses syntax. functions return copy object, unless stated otherwise. Class consistent: sub-setting multi-dimensional objects specifying dimensions (.e. rows, columns, …) use drop = FALSE. matrix , matrix . functions deliver results data.frames, data.tables, tibbles, tidytables. longer one re-learn different brackets-based sub-setting rules different types data.frame-like objects. Powered subclass agnostic ‘C’-code ‘collapse’ ‘data.table’. Explicit copy semantics: Sub-set operations change memory allocations, always return modified copy object. sub-set operations just change values -place (similar [<- [[<- methods) user can choose method modifies object reference, choose method returns deep copy. Careful handling names attributes: Sub-setting object index names returns indices name, just first. Data.frame-like objects (see supported classes ) forced unique column names. Attributes data.frame-like objects (see supported classes ) always preserved sub-setting. object types, user can specify whether preserve Attributes, use R’s [ attribute behaviour (.e. drop attributes). ensure compatibility R-packages create attribute behaviour sub-setting. Support wide variety S3 classes: Support atomic objects (vectors, matrices, arrays). Support factors. Support lists. Support following data.frame-like objects: data.frame, data.table, tibble, tidytable class, classes straight-forward inheritors classes (sf-data.frames sf-data.tables). Support column selection sub-setting used ggplot2’s aes() function. Support sub-setting characters single string. Since main functions S3 functions, packages may add functionality additional classes. Concise function argument names. Performance aware: Despite many checks performed, functions kept reasonably speedy, use ‘Rcpp’, ‘collapse’, ‘data.table’ R-packages. heavy lifting package done ‘collapse’ package.  ","code":""},{"path":"https://tony-aw.github.io/subsets/index.html","id":"methods-and-functions","dir":"","previous_headings":"","what":"Methods and Functions","title":"A Holistic Grammar of Subsets","text":"main focus following generic S3 methods: sb_x(): S3 method extract, exchange, duplicate subsets. sb_rm(): S3 method un-select (“remove”) subsets. sb_set(): S3 method modify (transform replace values) subsets object reference. Since ’s reference, allow coercion. sb_mod(): S3 method return copy object modified (transformed replaced values) subsets. auto-coercion certain extent. sb_coe(): S3 method coerce transform whole object, recursive subset object. sb_before(), sb_after(): S3 methods insert new values index along dimension object. sb_rec(): function can combined methods, recursive sub-setting operations. Beside generic S3 methods, additional specialized sub-setting functions provided: aes_pro() with_pro(): programmatically friendly stable version () ggplot2::aes() functions. sb_str(): extract replace subset characters single string (single character treated single element). sb_a(): extract multiple attributes object. finally, couple helper functions creating ranges, sequences indices (often needed sub-setting) provided: n(): Nested version c(), short-hand list(). idx_by(): Compute grouped indices. seq_rec(): Recursive sequence generator (example generate Fibonacci sequence) seq_names(): create range indices specified starting ending name. sub2coord(), coord2ind(): Convert subscripts (array indices) coordinates, coordinates flat indices, vice-versa.   heavy lifting internal code package done ‘collapse’ package.  ","code":""},{"path":"https://tony-aw.github.io/subsets/index.html","id":"installing--loading","dir":"","previous_headings":"","what":"Installing & Loading","title":"A Holistic Grammar of Subsets","text":"One can install ‘subsets’ GitHub like : Special care taken make sure function names clear, function names unlikely conflict core R, recommended R packages, rstudioapi package, major packages fastverse. one can attach package - thus exposing functions namespace - using: user wish expose specific functions ‘subsets’ within specific environment, like within specific function, one can use following:  ","code":"remotes::install_github(\"https://github.com/tony-aw/subsets\") library(subsets) tinycodet::import_LL(\"subsets\", selection = ... )"},{"path":"https://tony-aw.github.io/subsets/index.html","id":"changelog-experimental-versions","dir":"","previous_headings":"","what":"Changelog (EXPERIMENTAL VERSIONS)","title":"A Holistic Grammar of Subsets","text":"31 October 2023: first GitHub upload. Also: Halloween! 12 November 2023: Optimised code . Update benchmarks representative sized objects. Merged sb_rp() sb_tf() sb_mod(), added sb_set(). Placed explanations common indexing arguments separate help page better overview (less typing ). Replaced .attr argument rat argument sb_x() sb_rm(). Added sub2ind ind2sub functions. 18 November 2023: Fixed several bugs sb_set() method. Added sb_coe() method. Added considerably tests. Expanded documentation bit. Expanded sub2ind - functions 4 comprehensive functions. sb_str() function now also replacement method. 22 November 2023: Made arguments sub2ind - functions consistent, also expanded documentation bit. Added expanded explanation classes argument x separate help file better overview (less typing ). Added badges. Improved tests bit. Added .onAttach() message function. aes_pro() function now uses formula input rather character input. 27 November 2023: Added rcl argument sb_*.array() methods, specifically 3-dimensional arrays. Produced tests, re-organised tests. Added with_pro() function, - like aes_pro() - programmatically friendly version (), works formula instead expression. Added reference ‘abind’ bibliography sb_before() sb_after() methods. Normalized order classes documentation generic methods ‘subsets’. Added n() function, short-hand list(), also functions nested version c(). Added additional help page explaining Non-Standard Evaluation (NSE); ‘subsets’ avoids usage NSE whenever possible. 1 December 2023: sb_mod() method, auto-coercion data.frame-like objects now allowed, provided rows specified (.e. whole columns ). Expanded help page sb_mod() function considerably. Fixed bug aes_pro(). Added safer_partialmatch() function. Added idx_by() function compute grouped indices. Added dt_* functions functional forms data.table operations. Cleaned internal code. Added yet tests (now 42,000 tests). Benchmark removed Read-: planning move website, build package bit stable. 14 December 2023: Experimental website published. 16 December 2023: Small documentation improvements.  ","code":""},{"path":"https://tony-aw.github.io/subsets/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 Tony Wilkes Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/aaa0_subsets.html","id":null,"dir":"Reference","previous_headings":"","what":"subsets: an Easy Grammar of Subsets — aaa0_subsets","title":"subsets: an Easy Grammar of Subsets — aaa0_subsets","text":"subsets: Easy Grammar Subsets","code":""},{"path":"https://tony-aw.github.io/subsets/reference/aaa0_subsets.html","id":"motivation","dir":"Reference","previous_headings":"","what":"Motivation","title":"subsets: an Easy Grammar of Subsets — aaa0_subsets","text":"","code":"Among programming languages, 'R' has perhaps one of the most flexible and comprehensive sub-setting functionality. But with flexibility often comes confusion and (apparent) inconsistencies. And 'R' is no exception.  This becomes quite apparent when one reads (online) documents such as \"The R Inferno\" by Patrick Burns, and \"Frustration: One Year With R\" by Reece Goding. These documents point out many inconsistencies, and sub-setting related inconsistencies make up a good portion of these documents.  To my surprise, there is no comprehensive R-package (as far as I could see at least) that actually attempts to \"fix\" the subset-related issues laid out in these and other such documents.  Famous subset-related R packages such as 'dplyr' and 'data.table' focus almost exclusive on data.frame-like objects, and occasionally even add more frustration in some aspects, like being not very programmatically friendly.  Thus, this R package was born.  Although this package was somewhat made for people who are new to 'R' (especially when coming from another programming language), and found themselves confused, I trust this package will be useful even for those who are quite experienced in 'R'."},{"path":"https://tony-aw.github.io/subsets/reference/aaa0_subsets.html","id":"goal-amp-properties","dir":"Reference","previous_headings":"","what":"Goal & Properties","title":"subsets: an Easy Grammar of Subsets — aaa0_subsets","text":"Goal 'subsets' package replace square-brackets operators per-sé, (see Extract), provide alternative sub-setting methods functions, used situations square-brackets operators inconvenient.  (hopefully) easier sub-setting methods functions following properties: Programmatically friendly: Non-standard evaluation quite controversial (good reasons), therefore completely absent R package. Name-based arguments instead position-based arguments. Missing arguments can filled NULL, instead using dark magic like base::quote(expr =    ). Functions pipe-friendly. Beginner friendly: (silent) vector recycling. Extracting removing subsets uses syntax. functions return copy object, unless stated otherwise. Class consistent: sub-setting multi-dimensional objects specifying dimensions (.e. rows, columns, ...) use drop = FALSE. matrix , matrix . functions deliver results data.frames, data.tables, tibbles, tidytables. longer one re-learn different brackets-based sub-setting rules different types data.frame-like objects. Powered subclass agnostic 'C'-code 'collapse' 'data.table'. Explicit copy semantics: Sub-set operations change memory allocations, always return modified copy object. sub-set operations just change values -place (similar [<- [[<- methods) user can choose method modifies object reference, choose method returns deep copy. Careful handling names attributes: Sub-setting object index names returns indices name, just first. Data.frame-like objects (see supported classes ) forced unique column names. Attributes data.frame-like objects (see supported classes ) always preserved sub-setting. object types, user can specify whether preserve Attributes, use R's [ attribute behaviour (.e. drop attributes). ensure compatibility R-packages create attribute behaviour sub-setting. Support wide variety S3 classes: Support atomic objects (vectors, matrices, arrays). Support factors. Support lists. Support following data.frame-like objects: data.frame, data.table, tibble, tidytable class, classes straight-forward inheritors classes (sf-data.frames sf-data.tables). Support column selection sub-setting used ggplot2's aes function. Support sub-setting characters single string. Since main functions S3 methods, packages may add functionality additional S3 classes. Concise function argument names. Performance aware:  Despite many checks performed, functions kept reasonably speedy, use 'Rcpp', 'collapse', 'data.table' R-packages. heavy lifting package done 'collapse' package.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/aaa0_subsets.html","id":"methods-and-functions","dir":"Reference","previous_headings":"","what":"Methods and Functions","title":"subsets: an Easy Grammar of Subsets — aaa0_subsets","text":"main focus following generic S3 methods: sb_x: S3 method extract, exchange, duplicate subsets. sb_rm: S3 method un-select (\"remove\") subsets. sb_set: S3 method modify (transform replace values) subsets object reference. Since reference, allow coercion. sb_mod: S3 method return copy object modified (transformed replaced values) subsets. auto-coercion certain extent. sb_coe: S3 method coerce transform whole object, recursive subset object. sb_before, sb_after: S3 methods insert new values index along dimension object. sb_rec: function accesses recursive subsets. Can combined S3 methods, recursive sub-setting operations. Additional specialized sub-setting functions provided: aes_pro with_pro: programmatically friendly stable version ggplot2::aes functions. sb_str: extract replace subset characters single string (single character treated single element). sb_a: extract multiple attributes object. finally, couple helper functions creating ranges, sequences, indices (often needed sub-setting) provided: n: Nested version c, short-hand list. idx_by: Compute grouped indices. seq_rec: Recursive sequence generator (example generate Fibonacci sequence). seq_names: create range indices specified starting ending name. sub2coord, coord2ind: Convert subscripts (array indices) coordinates, coordinates flat indices, vice-versa.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/aaa0_subsets.html","id":"help-pages","dir":"Reference","previous_headings":"","what":"Help pages","title":"subsets: an Easy Grammar of Subsets — aaa0_subsets","text":"explanation classes, class treated 'subsets', see subsets_classes.  explanation common indexing arguments generic methods, see subsets_indx_args.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/aaa0_subsets.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"subsets: an Easy Grammar of Subsets — aaa0_subsets","text":"badges shown documentation R-package made using services : https://shields.io/","code":""},{"path":[]},{"path":"https://tony-aw.github.io/subsets/reference/aaa0_subsets.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"subsets: an Easy Grammar of Subsets — aaa0_subsets","text":"Maintainer: Tony Wilkes tony_a_wilkes@outlook.com (ORCID)","code":""},{"path":"https://tony-aw.github.io/subsets/reference/aaa1_subsets_classes.html","id":null,"dir":"Reference","previous_headings":"","what":"Supported S3 classes, With Important Comments — aaa1_subsets_classes","title":"Supported S3 classes, With Important Comments — aaa1_subsets_classes","text":"sb_ generic methods support following categories S3 classes: atomic vector classes (vectors, matrices, arrays); factors; lists; data.frame-like classes data.frames, data.tables, tibbles, tidytables,  classes straight-forward inheritors classes (sf-data.frames sf-data.tables). categories classes quite different . vital understand differences, order use 'subsets' package properly.  Thus help page explain important properties important differences.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/aaa1_subsets_classes.html","id":"atomic-vector-classes","dir":"Reference","previous_headings":"","what":"Atomic Vector Classes","title":"Supported S3 classes, With Important Comments — aaa1_subsets_classes","text":"atomic vector basic class type.  Matrices Arrays just atomic vectors dimension attributes.  elements atomic vector class must atomic type (\"logical\", \"integer\", \"numeric\", \"complex\", \"character\" \"raw\").  Therefore, sb_coe method coerce entirety atomic vector, just subset .","code":""},{"path":"https://tony-aw.github.io/subsets/reference/aaa1_subsets_classes.html","id":"factor-class","dir":"Reference","previous_headings":"","what":"Factor Class","title":"Supported S3 classes, With Important Comments — aaa1_subsets_classes","text":"Factors property can store values defined \"levels\" attribute; values allowed, thus result NAs.  Thus sb_mod coerce replacement values factors! quite different atomic vector classes, can store infinite variety values (provided atomic type).  Due properties, sb_set() method factors.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/aaa1_subsets_classes.html","id":"list-class","dir":"Reference","previous_headings":"","what":"List Class","title":"Supported S3 classes, With Important Comments — aaa1_subsets_classes","text":"Lists recursive objects (.e. can nested), actually store values rather store reference objects.  Therefore sb_rec method can used access recursive subsets list, matter deep/low hierarchy list.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/aaa1_subsets_classes.html","id":"data-frame-like-classes","dir":"Reference","previous_headings":"","what":"Data.frame-like classes","title":"Supported S3 classes, With Important Comments — aaa1_subsets_classes","text":"data.frame-like objects quite different previously named classes.  different data.frame-like classes also differ quite bit - especially terms sub-setting.  'subsets' R-package attempts keep data.frame methods class agnostic possible, class agnostic functionality 'collapse' 'data.table' R-packages.  3 things cause important oddities data.frame-like classes treated differently classes: Whole-columns auto-coerced replaced/transformed sb_mod(), partial columns auto-coerced. sb_x sb_rm methods always automatically conserve attributes (though names adjusted accordingly, course), never stripped, unlike classes. Giving data.frame-like object non-unique column names sb_-methods returns error. Also, duplicating columns sb_x automatically adjust column names make unique.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/aaa2_subsets_indx_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Index Arguments in the Generic Sub-setting Methods — aaa2_subsets_indx_args","title":"Index Arguments in the Generic Sub-setting Methods — aaa2_subsets_indx_args","text":"6 types arguments can used generic methods 'subsets' specify indices perform operations : : specify flat (.e. dimensionless) indices. row, col: specify rows /columns tabular objects. idx, dims: specify indices arbitrary dimensions arrays. rcl: specify rows (first dimension), columns (second dimension), layers (third dimension), arrays exactly 3 dimensions. lvl: specify levels, factors . filter, vars: specify rows /columns specifically data.frame-like objects.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/aaa2_subsets_indx_args.html","id":"argument-i","dir":"Reference","previous_headings":"","what":"Argument i","title":"Index Arguments in the Generic Sub-setting Methods — aaa2_subsets_indx_args","text":"following can specified argument : NULL, multi-dimensional objects factors, specifying arguments (.e. dimensional indices factor levels.) vector length 0, case indices selected operation (.e. empty selection). strictly positive integer vector indices. logical vector (without NAs!), length x, giving indices select operation. character vector index names. object multiple indices given name, corresponding indices selected operation. function returns logical vector, giving element indices select operation. Using arguments corresponds something like following:   brief explanation relationship flat indices (), dimension indices (row, col, etc.), see Details section sub2ind.","code":"sb_x(x, i = i) ==> x[i]"},{"path":"https://tony-aw.github.io/subsets/reference/aaa2_subsets_indx_args.html","id":"arguments-row-col","dir":"Reference","previous_headings":"","what":"Arguments row, col","title":"Index Arguments in the Generic Sub-setting Methods — aaa2_subsets_indx_args","text":"following can specified arguments row / col: NULL (default), corresponds missing argument, results indices dimension selected operation. vector length 0, case indices selected operation (.e. empty selection). strictly positive integer vector dimension indices select operation. logical vector (without NAs!) length corresponding dimension size, giving indices dimension select operation. character vector index names. object multiple indices given name, corresponding indices selected operation. NOTE: arguments row col ignored specified. Using row, col arguments corresponds something like following:","code":"sb_x(x, row = row, col = col) ==> x[row, col, drop = FALSE]"},{"path":"https://tony-aw.github.io/subsets/reference/aaa2_subsets_indx_args.html","id":"arguments-idx-dims","dir":"Reference","previous_headings":"","what":"Arguments idx, dims","title":"Index Arguments in the Generic Sub-setting Methods — aaa2_subsets_indx_args","text":"idx must list indices. dims must integer vector length idx, giving dimensions indices given idx correspond .  elements idx follow rules rules row col, EXCEPT one fill NULL.  NOTE: arguments idx dims ignored specified.  keep syntax short, user can use n function instead list() specify idx.  Using idx, dims arguments, corresponds something like following, using example 4-dimensional array:","code":"sb_x(x, n(1:10, 1:5), c(1, 3)) ==> x[1:10, , 1:5, , drop = FALSE]"},{"path":"https://tony-aw.github.io/subsets/reference/aaa2_subsets_indx_args.html","id":"arguments-rcl","dir":"Reference","previous_headings":"","what":"Arguments rcl","title":"Index Arguments in the Generic Sub-setting Methods — aaa2_subsets_indx_args","text":"rcl argument applicable arrays exactly 3 dimensions.  user knows -priori array 3 dimensions, using rcl efficient using idx, dims arguments.  rcl argument must list exactly 3 elements, first element giving indices first dimension (rows), second element giving indices second dimension (columns), third element giving indices third last dimension (layers); thus rcl stands \"rows, columns, layers\" (.e. 3 dimensions 3-dimensional array).  aforementioned 3 elements list rcl, following can specified: NULL, corresponds missing argument, results indices dimension selected operation. vector length 0, case indices selected operation (.e. empty selection). strictly positive integer vector dimension indices select operation. logical vector (without NAs!) length corresponding dimension size, giving indices dimension select operation. character vector index names. object multiple indices given name, corresponding indices selected operation. default rcl list simply NULL, used specifying arguments (either idx, dims ).  keep syntax short, user can use n function instead list() specify rcl.  Using rcl argument corresponds something like following:","code":"sb_x(x, rcl = n(NULL, 1:10, 1:5)) ==> x[, 1:10, 1:5, drop = FALSE]"},{"path":"https://tony-aw.github.io/subsets/reference/aaa2_subsets_indx_args.html","id":"argument-lvl","dir":"Reference","previous_headings":"","what":"Argument lvl","title":"Index Arguments in the Generic Sub-setting Methods — aaa2_subsets_indx_args","text":"argument, names levels x can given, selecting corresponding indices operation.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/aaa2_subsets_indx_args.html","id":"arguments-filter-vars","dir":"Reference","previous_headings":"","what":"Arguments filter, vars","title":"Index Arguments in the Generic Sub-setting Methods — aaa2_subsets_indx_args","text":"filter must one-sided formula single logical expression using column names data.frame, giving condition observation/row indices selected operation.  example, perform operation rows column height > 2 column sex != \"female\", specify following formula:   vars must function returns logical vector, giving column indices select operation.  example, select numeric columns, specify vars = .numeric.","code":"~ (height > 2) & (sex != \"female\")"},{"path":"https://tony-aw.github.io/subsets/reference/aaa2_subsets_indx_args.html","id":"duplicates-for-names-integers-and-levels-","dir":"Reference","previous_headings":"","what":"Duplicates (for Names, Integers, and Levels)","title":"Index Arguments in the Generic Sub-setting Methods — aaa2_subsets_indx_args","text":"Generally speaking, duplicate names, integers, levels allowed index selection.  exception sb_x method, method can used duplicating indices.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/aaa2_subsets_indx_args.html","id":"disallowed-combinations-of-index-arguments","dir":"Reference","previous_headings":"","what":"Disallowed Combinations of Index Arguments","title":"Index Arguments in the Generic Sub-setting Methods — aaa2_subsets_indx_args","text":"One specify  indexing arguments simultaneously; either , arguments.  arguments  evaluated following order: Argument Argument lvl (factors) argument rcl (3-dimensional arrays) rest indexing arguments. One specify row filter simultaneously. either one . Similarly, one specify col vars simultaneously.  cases holds one set specified, set ignored.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/aaa2_subsets_indx_args.html","id":"first-last-and-shuffle","dir":"Reference","previous_headings":"","what":"First, Last, and Shuffle","title":"Index Arguments in the Generic Sub-setting Methods — aaa2_subsets_indx_args","text":"indices counted forward. .e. 1 first element, last.  One can use tail function get last N indices.  One can use head function get first N indices.  shuffle elements indices, use sample function.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/aaa2_subsets_NSE.html","id":null,"dir":"Reference","previous_headings":"","what":"Controversy Surrounding Non-Standard Evaluation — aaa3_subsets_NSE","title":"Controversy Surrounding Non-Standard Evaluation — aaa3_subsets_NSE","text":"Non-Standard Evaluation (sometimes abbreviated \"NSE\"), quite controversial.  Consider following example:   package attached? 'ggplot2', error occur. Instead, package 'aplot' attached.  due evaluating expression 'aplot' quoted expression, instead evaluating contents (.e. string formula) variable. words: Non-Standard Evaluation.  standard evaluated expression works better.  Standard evaluation 'R' limited characters. Formulas can also used. example, library() function support formula input, following correctly load 'ggplot2':","code":"aplot <- \"ggplot2\" library(aplot) aplot <- ~ ggplot2 library(aplot)"},{"path":"https://tony-aw.github.io/subsets/reference/dt.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional forms of data.table Operations (also work on tidytables) — dt","title":"Functional forms of data.table Operations (also work on tidytables) — dt","text":"Functional forms special data.table operations - programmatically friendly (Non-Standard Evaluation). dt_aggregate() aggregates data.table tidytable, returns aggregated copy. dt_setcoe() coercively transforms columns data.table tidytable REFERENCE.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/dt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional forms of data.table Operations (also work on tidytables) — dt","text":"","code":"dt_aggregate(x, SDcols = NULL, f, by, order_by = FALSE)  dt_setcoe(x, col = NULL, vars = NULL, f)"},{"path":"https://tony-aw.github.io/subsets/reference/dt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional forms of data.table Operations (also work on tidytables) — dt","text":"x data.table tidytable. SDcols atomic vector, giving columns aggregation function f() applied . f aggregation function atomic vector, giving grouping columns. order_by logical (TRUE FALSE), indicating aggregated result ordered columns specified . col, vars columns select coercion; see subsets_indx_args.  Duplicates allowed.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/dt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional forms of data.table Operations (also work on tidytables) — dt","text":"sub-setted object.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/dt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional forms of data.table Operations (also work on tidytables) — dt","text":"","code":"requireNamespace(\"sf\") && requireNamespace(\"ggplot2\") #> [1] TRUE   # dt_aggregate on sf-data.table ====  x <- sf::st_read(system.file(\"shape/nc.shp\", package = \"sf\")) #> Reading layer `nc' from data source `D:\\Programs\\R-4.3.2\\library\\sf\\shape\\nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 x <- data.table::as.data.table(x)  x$region <- ifelse(x$CNTY_ID <= 2000, 'high', 'low') plotdat <- dt_aggregate(   x, SDcols = \"geometry\", f= sf::st_union, by = \"region\" )  ggplot2::ggplot(plotdat, aes_pro(geometry = ~ geometry, fill = ~ region)) +    ggplot2::geom_sf() #> ggplot2::aes(geometry = geometry, fill = region)   #############################################################################   # dt_setcoe ====  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb_set(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 1 1 2 2 2 2 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 3 3 3 3 4 4 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  obj <- data.table::data.table(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) dt_setcoe(obj, vars = is.numeric, f = as.numeric) # integers are now numeric str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>  sb_set(obj,   filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed; so no warnings )  str(obj) #> Classes 'data.table' and 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 1.41 1.73 2 2.24 ... #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 3.46 3.61 3.74 3.87 ... #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 #>  - attr(*, \".internal.selfref\")=<externalptr>"},{"path":"https://tony-aw.github.io/subsets/reference/exported_uilities.html","id":null,"dir":"Reference","previous_headings":"","what":"Exported Utilities — indx_x","title":"Exported Utilities — indx_x","text":"Exported utilities","code":""},{"path":"https://tony-aw.github.io/subsets/reference/exported_uilities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exported Utilities — indx_x","text":"","code":"indx_x(i, x, xnames, xsize)  indx_rm(i, x, xnames, xsize)"},{"path":"https://tony-aw.github.io/subsets/reference/exported_uilities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exported Utilities — indx_x","text":"See subsets_indx_args. x vector, vector-like object, factor, data.frame, data.frame-like object, list. xnames names dimension names xsize length dimension size","code":""},{"path":"https://tony-aw.github.io/subsets/reference/exported_uilities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exported Utilities — indx_x","text":"subsetted object.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/exported_uilities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exported Utilities — indx_x","text":"","code":"x <- 1:10 names(x) <- letters[1:10] indx_x(1:5, x, names(x), length(x)) #> [1] 1 2 3 4 5 indx_rm(1:5, x, names(x), length(x)) #> [1]  6  7  8  9 10"},{"path":"https://tony-aw.github.io/subsets/reference/idx_by.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Grouped Indices — idx_by","title":"Compute Grouped Indices — idx_by","text":"Given: sub-set function f; complete range indices r object x; grouping factor grp; idx_by() function takes indices f(r) per group grp.  result idx_by() can supplied indexing arguments (see subsets_indx_args) : sb_x, sb_rm, sb_mod, sb_set, sb_coe,  perform grouped subset operations.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/idx_by.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Grouped Indices — idx_by","text":"","code":"idx_by(f, r, grp, parallel = FALSE, mc.cores = 1L)"},{"path":"https://tony-aw.github.io/subsets/reference/idx_by.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Grouped Indices — idx_by","text":"f subset function applied per group r.  function must accept character integer vector input, produce character integer vector output.  example, subset last element per group, specify: f = \\() tail(, 1) r integer character vector, giving complete range indices object.  example: colnames(x), 1:nrow(x), etc. grp factor giving groups. Make sure order corresponds r, otherwise makes sense. parallel, mc.cores see .","code":""},{"path":"https://tony-aw.github.io/subsets/reference/idx_by.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Grouped Indices — idx_by","text":"vector indices type r.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/idx_by.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Grouped Indices — idx_by","text":"","code":"# vectors ==== (a <- 1:20) #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 (grp <- factor(rep(letters[1:5], each = 4))) #>  [1] a a a a b b b b c c c c d d d d e e e e #> Levels: a b c d e  # get the last element of `a` for each group in `grp`: i <- idx_by(\\(i)tail(i, 1), 1:length(a), grp) sb_x(cbind(a, grp), row = i) #>       a grp #> [1,]  4   1 #> [2,]  8   2 #> [3,] 12   3 #> [4,] 16   4 #> [5,] 20   5   # data.frame ==== x <- data.frame(   a = sample(1:20),   b = letters[1:20],   group = factor(rep(letters[1:5], each = 4)) ) print(x) #>     a b group #> 1  15 a     a #> 2  10 b     a #> 3   9 c     a #> 4  19 d     a #> 5   3 e     b #> 6   1 f     b #> 7  17 g     b #> 8   2 h     b #> 9  16 i     c #> 10  6 j     c #> 11 18 k     c #> 12 11 l     c #> 13 20 m     d #> 14 12 n     d #> 15 13 o     d #> 16  8 p     d #> 17  7 q     e #> 18  4 r     e #> 19  5 s     e #> 20 14 t     e # get the first row for each group in data.frame `x`: row <- idx_by(\\(i)head(i, 1), 1:nrow(x), x$group) sb_x(x, row) #>    a b group #> 1 15 a     a #> 2  3 e     b #> 3 16 i     c #> 4 20 m     d #> 5  7 q     e # get the first row for each group for which a > 10: x2 <- sb_x(x, filter = ~ a > 10) row <- na.omit(idx_by(\\(i)head(i, 1), 1:nrow(x2), x2$group)) sb_x(x2, row) #>    a b group #> 1 15 a     a #> 2 17 g     b #> 3 16 i     c #> 4 20 m     d #> 5 14 t     e"},{"path":"https://tony-aw.github.io/subsets/reference/nest.html","id":null,"dir":"Reference","previous_headings":"","what":"Nest — n","title":"Nest — n","text":"c() function concatenates vectors lists vector (possible) else list.  analogy function, n() function nests objects list (atomic vector, atomic vectors nested).  short-hand version list function.  handy lists often needed 'subsets', especially arrays.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/nest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nest — n","text":"","code":"n()"},{"path":"https://tony-aw.github.io/subsets/reference/nest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nest — n","text":"list.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/nest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nest — n","text":"","code":"obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_x(obj, n(1:3, 1:2), c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #>  # above is equivalent to obj[1:3, , 1:2, drop = FALSE]"},{"path":"https://tony-aw.github.io/subsets/reference/pro.html","id":null,"dir":"Reference","previous_headings":"","what":"Programmatically Friendly, Standard Evaluated Versions of with() and ggplot2::aes() — aes_pro","title":"Programmatically Friendly, Standard Evaluated Versions of with() and ggplot2::aes() — aes_pro","text":"Programmatically friendly versions ggplot2::aes functions. alternative functions programmatically friendly uses proper standard evaluation, instead non-standard evaluation, tidy evaluation, similar programmatically unfriendly evaluations.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/pro.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Programmatically Friendly, Standard Evaluated Versions of with() and ggplot2::aes() — aes_pro","text":"","code":"aes_pro(...)  with_pro(data, form)"},{"path":"https://tony-aw.github.io/subsets/reference/pro.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Programmatically Friendly, Standard Evaluated Versions of with() and ggplot2::aes() — aes_pro","text":"... arguments passed aes, given one-sided formulas, rather non-standard evaluated dark magic. data list, environment, data.frame. form one-sided formula giving expression evaluate. Global variables allowed, variables actually present data.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/pro.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Programmatically Friendly, Standard Evaluated Versions of with() and ggplot2::aes() — aes_pro","text":"See aes.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/pro.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Programmatically Friendly, Standard Evaluated Versions of with() and ggplot2::aes() — aes_pro","text":"Non-Standard Evaluation quite controversial (see subsets_NSE).  Often standard-evaluated alternatives provided.  case aes() function 'ggplot2', standard-evaluated alternative changes frequently, ones provided far rather clumsy.  aes_pro() function standard evaluated alternative. Due way aes_pro() programmed, work matter many times standard evaluation techniques change 'ggplot2'.  also work older newer versions 'ggplot2'.  support functions combinations references variables, input used formula inputs, rather character inputs.  See Examples section .","code":""},{"path":"https://tony-aw.github.io/subsets/reference/pro.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Programmatically Friendly, Standard Evaluated Versions of with() and ggplot2::aes() — aes_pro","text":"","code":"requireNamespace(\"ggplot2\")   data(\"mpg\", package = \"ggplot2\") x <- ~ cty y <- ~ sqrt(hwy) color <- ~ drv  ggplot2::ggplot(mpg, aes_pro(x, y, color = color)) +   ggplot2::geom_point() #> ggplot2::aes(cty, sqrt(hwy), color = drv)   myform <- ~ sqrt(hwy) mpg$hwy_sqrt <- with_pro(mpg, myform) summary(mpg) #>  manufacturer          model               displ            year      #>  Length:234         Length:234         Min.   :1.600   Min.   :1999   #>  Class :character   Class :character   1st Qu.:2.400   1st Qu.:1999   #>  Mode  :character   Mode  :character   Median :3.300   Median :2004   #>                                        Mean   :3.472   Mean   :2004   #>                                        3rd Qu.:4.600   3rd Qu.:2008   #>                                        Max.   :7.000   Max.   :2008   #>       cyl           trans               drv                 cty        #>  Min.   :4.000   Length:234         Length:234         Min.   : 9.00   #>  1st Qu.:4.000   Class :character   Class :character   1st Qu.:14.00   #>  Median :6.000   Mode  :character   Mode  :character   Median :17.00   #>  Mean   :5.889                                         Mean   :16.86   #>  3rd Qu.:8.000                                         3rd Qu.:19.00   #>  Max.   :8.000                                         Max.   :35.00   #>       hwy             fl               class              hwy_sqrt     #>  Min.   :12.00   Length:234         Length:234         Min.   :3.464   #>  1st Qu.:18.00   Class :character   Class :character   1st Qu.:4.243   #>  Median :24.00   Mode  :character   Mode  :character   Median :4.899   #>  Mean   :23.44                                         Mean   :4.802   #>  3rd Qu.:27.00                                         3rd Qu.:5.196   #>  Max.   :44.00                                         Max.   :6.633"},{"path":"https://tony-aw.github.io/subsets/reference/safer_dollar.html","id":null,"dir":"Reference","previous_headings":"","what":"Set safer dollar, arguments, and attribute matching — safer_partialmatch","title":"Set safer dollar, arguments, and attribute matching — safer_partialmatch","text":"function simply calls following:   Thus forces 'R' give warning partial matching occurs using dollar ($) operator, forms partial matching occurs.","code":"options(    warnPartialMatchDollar = TRUE,    warnPartialMatchArgs = TRUE,    warnPartialMatchAttr = TRUE  )"},{"path":"https://tony-aw.github.io/subsets/reference/safer_dollar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set safer dollar, arguments, and attribute matching — safer_partialmatch","text":"","code":"safer_partialmatch()"},{"path":"https://tony-aw.github.io/subsets/reference/safer_dollar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set safer dollar, arguments, and attribute matching — safer_partialmatch","text":"Sets options. Returns nothing.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/safer_dollar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set safer dollar, arguments, and attribute matching — safer_partialmatch","text":"","code":"if (FALSE) { # interactive() interactive()   safer_partialmatch() data(iris) head(iris) iris$Sepal.Length <- iris$Sepal.Length^2 head(iris) }"},{"path":"https://tony-aw.github.io/subsets/reference/sb_coe.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Coerce and Transform (Recursive Subsets of) an Object — sb_coe","title":"Method to Coerce and Transform (Recursive Subsets of) an Object — sb_coe","text":"S3 Method completely transform (recursive subsets ) object explicit coercion. Given coercing function v(), following can stated method. (1) atomic objects (vectors, matrices, arrays), method equivalent :   (2) factors, method equivalent :   (3) lists, one multiple elements specified argument , method equivalent :   (4) data.frame-like objects, one multiple columns specified argument col, method equivalent :   Note x data.table, one can coercively transform columns REFERENCE (memory efficient), using following code (columns specified col, coercive transformation function v):","code":"x[] <- v(x) x <- v(x) x[i] <- lapply(x[i], v) collapse::ftransformv(x, col, v) col <- ... # some integer/character vector of column indices/names x[, (col) := lapply(.SD, v), .SDcols = col]"},{"path":"https://tony-aw.github.io/subsets/reference/sb_coe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Coerce and Transform (Recursive Subsets of) an Object — sb_coe","text":"","code":"sb_coe(x, ...)  # S3 method for default sb_coe(x, v, ...)  # S3 method for factor sb_coe(x, v, ...)  # S3 method for list sb_coe(x, i, v, ...)  # S3 method for data.frame sb_coe(x, col = NULL, vars = NULL, v, ...)"},{"path":"https://tony-aw.github.io/subsets/reference/sb_coe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Coerce and Transform (Recursive Subsets of) an Object — sb_coe","text":"x see subsets_classes. ... arguments passed methods. v coercive transformation function use. , col, vars See subsets_indx_args.  empty index selection returns original object unchanged.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_coe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Coerce and Transform (Recursive Subsets of) an Object — sb_coe","text":"copy coercively transformed object.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_coe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Coerce and Transform (Recursive Subsets of) an Object — sb_coe","text":"replacing values reference, (recursive subset ) object never coerced, requires making deep copy; instead, replacement value coerced.  example:  Using sb_set() replacing/transform one values integer type (int) object / list element / data.frame column, become 1.5, coerce object / list element / data.frame column decimal type (dbl); instead, replacement 1.5 coerced integer 1.  reason, sb_coe() method can used coercively transform object replacing transforming values reference.  See also Examples section .","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_coe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Coerce and Transform (Recursive Subsets of) an Object — sb_coe","text":"","code":"obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 sb_set(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost ) #> Warning: 1.414214 (type 'double') at RHS position 1 truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') print(obj) #>     a b  c d #> 1   1 a 11 a #> 2   1 b  3 b #> 3   1 c  3 c #> 4   2 d  3 d #> 5   2 e  3 e #> 6   2 f  4 f #> 7   2 g  4 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) obj <- sb_coe(obj, vars = is.numeric, v = as.numeric) str(obj) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: num  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: num  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 sb_set(obj,   filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # SAFE: coercion performed; so no warnings )  print(obj) #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j"},{"path":"https://tony-aw.github.io/subsets/reference/sb_in.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods to Insert New Values Before or After an Index Along a Dimension — sb_before","title":"Methods to Insert New Values Before or After an Index Along a Dimension — sb_before","text":"sb_before() method inserts new values position along dimension.  sb_after() method inserts new values position along dimension.  functions use modified version abind::abind (see reference ).","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_in.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods to Insert New Values Before or After an Index Along a Dimension — sb_before","text":"","code":"sb_before(x, ...)  sb_after(x, ...)  # S3 method for default sb_before(x, new, pos = 1, .attr = NULL, ...)  # S3 method for default sb_after(x, new, pos = length(x), .attr = NULL, ...)  # S3 method for array sb_before(x, new, margin, pos = 1, .attr = NULL, ...)  # S3 method for array sb_after(x, new, margin, pos = dim(x)[margin], .attr = NULL, ...)  # S3 method for factor sb_before(x, new, pos = 1, .attr = NULL, ...)  # S3 method for factor sb_after(x, new, pos = length(x), .attr = NULL, ...)  # S3 method for list sb_before(x, new, pos = 1, .attr = NULL, ...)  # S3 method for list sb_after(x, new, pos = length(x), .attr = NULL, ...)  # S3 method for data.frame sb_before(x, new, margin, pos = 1, .attr = NULL, ...)  # S3 method for data.frame sb_after(x, new, margin, pos = collapse::fdim(x)[margin], .attr = NULL, ...)"},{"path":"https://tony-aw.github.io/subsets/reference/sb_in.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods to Insert New Values Before or After an Index Along a Dimension — sb_before","text":"x see subsets_classes. ... arguments passed methods. new new value(s). type object depends x: atomic objects, new can atomic object. However, one wished added values new named, ensure new type object x. example: use matrix column names new appending/inserting columns matrix x. factors, new must factor. lists, new must (possible named) list. data.frame-like objects, new must data.frame. pos strictly positive single integer scalar (duplicates), giving position along dimension (specified margin), new values added. .attr list, giving additional potentially missing attributes added returned object.  default, concatenation strips attributes, since attributes x new may equal even compatible.  attr argument, attributes merged object can specified.  attributes actually missing insertion added, thus preventing overwriting existing attributes like names.  One may, example, specify .attr = sb_a(x) .attr = sb_a(new).  NULL (default), attributes added post-insert.  speed important, NULL best option (attributes preserved). margin single scalar, giving dimension along add new values.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_in.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods to Insert New Values Before or After an Index Along a Dimension — sb_before","text":"Returns copy appended object.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_in.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Methods to Insert New Values Before or After an Index Along a Dimension — sb_before","text":"Plate T, Heiberger R (2016). abind: Combine Multidimensional Arrays. R package version 1.4-5, https://CRAN.R-project.org/package=abind.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_in.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods to Insert New Values Before or After an Index Along a Dimension — sb_before","text":"","code":"# atomic objects ====  x <- matrix(1:20 , ncol = 4) print(x) #>      [,1] [,2] [,3] [,4] #> [1,]    1    6   11   16 #> [2,]    2    7   12   17 #> [3,]    3    8   13   18 #> [4,]    4    9   14   19 #> [5,]    5   10   15   20 new <- -1 * x sb_before(x, new, 1) #>       [,1] [,2] [,3] [,4] #>  [1,]   -1   -6  -11  -16 #>  [2,]   -2   -7  -12  -17 #>  [3,]   -3   -8  -13  -18 #>  [4,]   -4   -9  -14  -19 #>  [5,]   -5  -10  -15  -20 #>  [6,]    1    6   11   16 #>  [7,]    2    7   12   17 #>  [8,]    3    8   13   18 #>  [9,]    4    9   14   19 #> [10,]    5   10   15   20 sb_before(x, new, 2) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]   -1   -6  -11  -16    1    6   11   16 #> [2,]   -2   -7  -12  -17    2    7   12   17 #> [3,]   -3   -8  -13  -18    3    8   13   18 #> [4,]   -4   -9  -14  -19    4    9   14   19 #> [5,]   -5  -10  -15  -20    5   10   15   20 sb_after(x, new, 1) #>       [,1] [,2] [,3] [,4] #>  [1,]    1    6   11   16 #>  [2,]    2    7   12   17 #>  [3,]    3    8   13   18 #>  [4,]    4    9   14   19 #>  [5,]    5   10   15   20 #>  [6,]   -1   -6  -11  -16 #>  [7,]   -2   -7  -12  -17 #>  [8,]   -3   -8  -13  -18 #>  [9,]   -4   -9  -14  -19 #> [10,]   -5  -10  -15  -20 sb_after(x, new, 2) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #> [1,]    1    6   11   16   -1   -6  -11  -16 #> [2,]    2    7   12   17   -2   -7  -12  -17 #> [3,]    3    8   13   18   -3   -8  -13  -18 #> [4,]    4    9   14   19   -4   -9  -14  -19 #> [5,]    5   10   15   20   -5  -10  -15  -20  #############################################################################   # factors ====  x <- factor(letters) new <- factor(\"foo\") sb_before(x, new) #>  [1] foo a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   #> [20] s   t   u   v   w   x   y   z   #> Levels: foo a b c d e f g h i j k l m n o p q r s t u v w x y z sb_after(x, new) #>  [1] a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   #> [20] t   u   v   w   x   y   z   foo #> Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z foo  #############################################################################   # lists ====  x <- as.list(1:5) new <- lapply(x, \\(x)x*-1) print(x) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>  sb_before(x, new) #> [[1]] #> [1] -1 #>  #> [[2]] #> [1] -2 #>  #> [[3]] #> [1] -3 #>  #> [[4]] #> [1] -4 #>  #> [[5]] #> [1] -5 #>  #> [[6]] #> [1] 1 #>  #> [[7]] #> [1] 2 #>  #> [[8]] #> [1] 3 #>  #> [[9]] #> [1] 4 #>  #> [[10]] #> [1] 5 #>  sb_after(x, new) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>  #> [[6]] #> [1] -1 #>  #> [[7]] #> [1] -2 #>  #> [[8]] #> [1] -3 #>  #> [[9]] #> [1] -4 #>  #> [[10]] #> [1] -5 #>   #############################################################################   # data.frame-like objects ====  x <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) new <- data.frame(e = 101:110) sb_before(x, new, 2) #>      e  a b  c d #> 1  101  1 a 11 a #> 2  102  2 b 12 b #> 3  103  3 c 13 c #> 4  104  4 d 14 d #> 5  105  5 e 15 e #> 6  106  6 f 16 f #> 7  107  7 g 17 g #> 8  108  8 h 18 h #> 9  109  9 i 19 i #> 10 110 10 j 20 j sb_after(x, new, 2) #>     a b  c d   e #> 1   1 a 11 a 101 #> 2   2 b 12 b 102 #> 3   3 c 13 c 103 #> 4   4 d 14 d 104 #> 5   5 e 15 e 105 #> 6   6 f 16 f 106 #> 7   7 g 17 g 107 #> 8   8 h 18 h 108 #> 9   9 i 19 i 109 #> 10 10 j 20 j 110 new <- x[1,] sb_before(x, new, 1) #>     a b  c d #> 1   1 a 11 a #> 2   1 a 11 a #> 3   2 b 12 b #> 4   3 c 13 c #> 5   4 d 14 d #> 6   5 e 15 e #> 7   6 f 16 f #> 8   7 g 17 g #> 9   8 h 18 h #> 10  9 i 19 i #> 11 10 j 20 j sb_after(x, new, 1) #>     a b  c d #> 1   1 a 11 a #> 2   2 b 12 b #> 3   3 c 13 c #> 4   4 d 14 d #> 5   5 e 15 e #> 6   6 f 16 f #> 7   7 g 17 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j #> 11  1 a 11 a"},{"path":"https://tony-aw.github.io/subsets/reference/sb_mod.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"S3 Method return copy object modified subsets.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_mod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"","code":"sb_mod(x, ...)  # S3 method for default sb_mod(x, i, ..., rp, tf)  # S3 method for matrix sb_mod(x, row = NULL, col = NULL, i = NULL, ..., rp, tf)  # S3 method for array sb_mod(x, idx = NULL, dims = NULL, rcl = NULL, i = NULL, ..., rp, tf)  # S3 method for factor sb_mod(x, i = NULL, lvl = NULL, ..., rp)  # S3 method for list sb_mod(x, i, ..., rp, tf)  # S3 method for data.frame sb_mod(   x,   row = NULL,   col = NULL,   filter = NULL,   vars = NULL,   coe = NULL,   ...,   rp,   tf )"},{"path":"https://tony-aw.github.io/subsets/reference/sb_mod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"x see subsets_classes. ... arguments passed methods. , lvl, row, col, idx, dims, rcl, filter, vars See subsets_indx_args.  empty index selection returns original object unchanged. rp object somewhat type selected subset x, length selected subset x length 1. tf transformation function. coe data.frame-like objects, sb_mod() can coerce whole columns, subsets columns.  automatically coerce column types row filter also specified.  Therefore, user can specify coercion function, applied entirety every column specified col vars; columns outside subset affected.  coercion function , course, applied replacement (rp) transformation (tf()).  default, coe = NULL means columns coercively transformed.  See also Auto-Coercion Rules Examples sections , also see sb_coe.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_mod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"copy object replaced/transformed values.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_mod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"Transform Replace  Specifying argument tf transform subset.  Specifying rp replace subset.  One specify tf rp. either one set .  Note tf argument available factors: intentional.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_mod.html","id":"auto-coercion-rules","dir":"Reference","previous_headings":"","what":"Auto-Coercion Rules","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"Atomic objects  Atomic objects automatically coerced fit replaced values.  example, replacing one multiple values integer vector (type int) decimal number (type dbl) coerce entire vector type dbl. Factors  Factors accept values part levels, thus support coercion.  Replacing value new value part levels, result replacement value NA. Data.frame-like objects replacing/transforming whole columns  replacing whole columns, row = NULL filter = NULL, coercion takes place according contents column.  .e. column atomic, follows atomic rules, factor, follows rules factor, etc.  Note coercion columns needs row = NULL filter = NULL; auto-coercion take place specifying something like row = 1:nrow(x) (see next section). Data.frame-like objects partially replacing/transforming columns  rows specified, thus whole columns parts columns replaced transformed, auto-coercion takes place.  .e.: replacing/transforming value integer (int) column become 1.5, coerce column decimal type (dbl); instead, replacement value 1.5 coerced integer 1.  coe argument allows user enforce coercion, even subsets columns replaced/transformed instead whole columns.  Specifically, coe arguments allows user specify coercive function applied entirety every column specified col vars; columns outside subset affected.  coercion function , course, applied replacement (rp) transformation (tf()). Lists  Lists allow complete change elements, since lists merely pointers.  However, recursive subset list list, follows coercion rules whatever class recursive subset .","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_mod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Return a Copy of an Object With Modified Subsets — sb_mod","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 rp <- -1:-9 sb_mod(obj, 1:3, 1:3, rp = rp) #>       a  b  c  a #> [1,] -1 -4 -7 13 #> [2,] -2 -5 -8 14 #> [3,] -3 -6 -9 15 #> [4,]  4  8 12 16 # above is equivalent to  obj[1:3, 1:3] <- -1:-9; obj sb_mod(obj, i = \\(x)x<=5, rp = -1:-5) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- -1:-5; obj sb_mod(obj, col = \"a\", rp = -1:-8) #>       a b  c  a #> [1,] -1 5  9 -5 #> [2,] -2 6 10 -6 #> [3,] -3 7 11 -7 #> [4,] -4 8 12 -8 # above is equivalent to  obj[, which(colnames(obj) %in% \"a\")] <- -1:-8; obj sb_mod(obj, 1:3, 1:3, tf = \\(x) -x) #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 # above is equivalent to  obj[1:3, 1:3] <- (-1 * obj[1:3, 1:3]); obj sb_mod(obj, i = \\(x)x<=5, tf = \\(x) -x) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- (-1 * obj[obj <= 5]); obj  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_mod(obj, 1:3, 1:3, tf = \\(x) -x) #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 # above is equivalent to  obj[1:3, 1:3] <- -1 * obj[1:3, 1:3] sb_mod(obj, i = \\(x)x<=5, tf = \\(x) -x) #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 # above is equivalent to  obj[obj <= 5] <- -1:-5; obj sb_mod(obj, col = \"a\", tf = \\(x) -x) #>       a b  c   a #> [1,] -1 5  9 -13 #> [2,] -2 6 10 -14 #> [3,] -3 7 11 -15 #> [4,] -4 8 12 -16 # above is equivalent to  obj[, which(colnames(obj) %in% \"a\")] <- -1:-8; obj  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_mod(obj, list(1:3, 1:2), c(1,3), rp = -1:-24) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -4   -7  -10 #> [2,]   -2   -5   -8  -11 #> [3,]   -3   -6   -9  -12 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]  -13  -16  -19  -22 #> [2,]  -14  -17  -20  -23 #> [3,]  -15  -18  -21  -24 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  # above is equivalent to obj[1:3, , 1:2] <- -1:-24 sb_mod(obj, i = \\(x)x<=5, rp = -1:-5) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -5    9   13 #> [2,]   -2    6   10   14 #> [3,]   -3    7   11   15 #> [4,]   -4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  # above is equivalent to obj[obj <= 5] <- -1:-5  #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb_mod(obj, \"a\", rp = list(1L)) #> $a #> [1] 1 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to  obj[[\"a\"]] <- 1L; obj sb_mod(obj, is.numeric, rp = list(-1:-10, -11:-20)) #> $a #>  [1]  -1  -2  -3  -4  -5  -6  -7  -8  -9 -10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] -11 -12 -13 -14 -15 -16 -17 -18 -19 -20 #>  # above is equivalent to  obj[which(sapply(obj, is.numeric))] <- list(-1:-10, -11:-20); obj  #############################################################################   # data.frame-like objects ==== obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10  sb_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost )  #> Warning: 1.414214 (type 'double') at RHS position 1 truncated (precision lost) when assigning to type 'integer' (column 1 named 'a') #> Warning: 3.464102 (type 'double') at RHS position 1 truncated (precision lost) when assigning to type 'integer' (column 3 named 'c') #>     a b  c d #> 1   1 a 11 a #> 2   1 b  3 b #> 3   1 c  3 c #> 4   2 d  3 d #> 5   2 e  3 e #> 6   2 f  4 f #> 7   2 g  4 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb_mod(   obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,   coe = as.double, tf = sqrt # SAFE: coercion performed )  #>            a b         c d #> 1   1.000000 a 11.000000 a #> 2   1.414214 b  3.464102 b #> 3   1.732051 c  3.605551 c #> 4   2.000000 d  3.741657 d #> 5   2.236068 e  3.872983 e #> 6   2.449490 f  4.000000 f #> 7   2.645751 g  4.123106 g #> 8   8.000000 h 18.000000 h #> 9   9.000000 i 19.000000 i #> 10 10.000000 j 20.000000 j  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) str(obj) # notice that columns \"a\" and \"c\" are INTEGER (`int`) #> 'data.frame':\t10 obs. of  4 variables: #>  $ a: int  1 2 3 4 5 6 7 8 9 10 #>  $ b: chr  \"a\" \"b\" \"c\" \"d\" ... #>  $ c: int  11 12 13 14 15 16 17 18 19 20 #>  $ d: Factor w/ 10 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5 6 7 8 9 10 sb_mod(   obj, vars = is.numeric,   tf = sqrt # SAFE: row=NULL & filter = NULL, so regular auto-coercion ) #>           a b        c d #> 1  1.000000 a 3.316625 a #> 2  1.414214 b 3.464102 b #> 3  1.732051 c 3.605551 c #> 4  2.000000 d 3.741657 d #> 5  2.236068 e 3.872983 e #> 6  2.449490 f 4.000000 f #> 7  2.645751 g 4.123106 g #> 8  2.828427 h 4.242641 h #> 9  3.000000 i 4.358899 i #> 10 3.162278 j 4.472136 j"},{"path":"https://tony-aw.github.io/subsets/reference/sb_rec.html","id":null,"dir":"Reference","previous_headings":"","what":"Access Recursive Subsets — sb_rec","title":"Access Recursive Subsets — sb_rec","text":"sb_rec() method allows user access recursive subsets lists, can combined (.e. piped) generic methods provided 'subsets'.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_rec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access Recursive Subsets — sb_rec","text":"","code":"sb_rec(lst, rec)"},{"path":"https://tony-aw.github.io/subsets/reference/sb_rec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access Recursive Subsets — sb_rec","text":"lst list, list-like object. rec vector length p, lst[[rec]] equivalent lst[[ rec[1] ]]...[[ rec[p] ]], providing final indexing results list.  certain subset level nested list, multiple subsets name exist, first one selected performing recursive indexing name, due recursive nature type subsetting.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_rec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Access Recursive Subsets — sb_rec","text":"sub-setted object.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_rec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Access Recursive Subsets — sb_rec","text":"","code":"lst <- list(   A = list(     A = list(A = \"AAA\", B = \"AAB\"),     A = list(A  = \"AA2A\", B = \"AA2B\"),     B = list(A = \"ABA\", B = \"ABB\")   ),   B = list(     A = list(A = \"BAA\", B = \"BAB\"),     B = list(A = \"BBA\", B = \"BBB\")   ) ) sb_rec(lst, c(1,2,2)) # this gives \"AA2B\" #> [1] \"AA2B\" sb_rec(lst, c(\"A\", \"B\", \"B\")) # this gives \"ABB\" #> [1] \"ABB\" sb_rec(lst, c(2,2,1)) # this gives \"BBA\" #> [1] \"BBA\" sb_rec(lst, c(\"B\", \"B\", \"A\")) # this gives \"BBA\" #> [1] \"BBA\"  # return a modified copy of the second-lowest level, # where replace \"ABB\" is replaced with -1: sb_rec(lst, c(\"A\", \"B\")) |> sb_coe(i = \"B\", v = as.double) |> sb_mod(i = \"B\", rp = list(-1))  #> Warning: NAs introduced by coercion #> $A #> [1] \"ABA\" #>  #> $B #> [1] -1 #>   # replace \"AAA\" with -1 BY REFERENCE: sb_rec(lst, c(\"A\", \"A\")) |> sb_set(i = \"A\", rp = list(-1)) lst # notice the first element is replaced by -1 #> $A #> $A$A #> $A$A$A #> [1] -1 #>  #> $A$A$B #> [1] \"AAB\" #>  #>  #> $A$A #> $A$A$A #> [1] \"AA2A\" #>  #> $A$A$B #> [1] \"AA2B\" #>  #>  #> $A$B #> $A$B$A #> [1] \"ABA\" #>  #> $A$B$B #> [1] \"ABB\" #>  #>  #>  #> $B #> $B$A #> $B$A$A #> [1] \"BAA\" #>  #> $B$A$B #> [1] \"BAB\" #>  #>  #> $B$B #> $B$B$A #> [1] \"BBA\" #>  #> $B$B$B #> [1] \"BBB\" #>  #>  #>"},{"path":"https://tony-aw.github.io/subsets/reference/sb_rm.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Un-Select Subsets of an Object — sb_rm","title":"Method to Un-Select Subsets of an Object — sb_rm","text":"S3 Method un-select subsets object.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_rm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Un-Select Subsets of an Object — sb_rm","text":"","code":"sb_rm(x, ...)  # S3 method for default sb_rm(x, i, ..., rat = FALSE)  # S3 method for matrix sb_rm(x, row = NULL, col = NULL, i = NULL, ..., rat = FALSE)  # S3 method for array sb_rm(x, idx = NULL, dims = NULL, rcl = NULL, i = NULL, ..., rat = FALSE)  # S3 method for factor sb_rm(x, i = NULL, lvl = NULL, drop = FALSE, ..., rat = FALSE)  # S3 method for list sb_rm(x, i, drop = FALSE, ..., rat = FALSE)  # S3 method for data.frame sb_rm(x, row = NULL, col = NULL, filter = NULL, vars = NULL, ...)"},{"path":"https://tony-aw.github.io/subsets/reference/sb_rm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Un-Select Subsets of an Object — sb_rm","text":"x see subsets_classes. ... arguments passed methods. , lvl, row, col, idx, dims, rcl, filter, vars See subsets_indx_args.  empty index selection results nothing removed, entire object returned. rat logical, indicating attributes returned sub-setted object. See Details section info. drop logical. factors: drop = TRUE, unused levels dropped, drop = FALSE dropped. lists: drop = TRUE, selecting single element give simplified result, like using [[]]. drop = FALSE, list always returned regardless number elements.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_rm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Un-Select Subsets of an Object — sb_rm","text":"copy sub-setted object.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_rm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Un-Select Subsets of an Object — sb_rm","text":"One rat argument  [ - methods strip () attributes.  rat = FALSE, default behaviour preserved, compatibility special classes. fastest option.  rat = TRUE, attributes x missing sub-setting re-assigned x. Already existing attributes sub-setting overwritten.  rat argument data.frame-like object: attributes always preserved.  NOTE: following situations, rat argument ignored, attributes necessarily dropped: x list, drop = TRUE, single element selected. x matrix array, sub-setting done argument.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_rm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Un-Select Subsets of an Object — sb_rm","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_rm(obj, 1:3, 1:3) #>       a #> [1,] 16 # above is equivalent to  obj[-1:-3, -1:-3, drop = FALSE] sb_rm(obj, i = \\(x)x>5) #> [1] 1 2 3 4 5 # above is equivalent to  obj[!obj > 5] sb_rm(obj, col = \"a\") #>      b  c #> [1,] 5  9 #> [2,] 6 10 #> [3,] 7 11 #> [4,] 8 12 # above is equivalent to  obj[, which(!colnames(obj) %in% \"a\")]  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_rm(obj, n(1, c(1, 3)), c(1, 3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   18   22   26   30 #> [2,]   19   23   27   31 #> [3,]   20   24   28   32 #>  sb_rm(obj, rcl = n(1, NULL, c(1, 3))) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   18   22   26   30 #> [2,]   19   23   27   31 #> [3,]   20   24   28   32 #>  # above 2 lines are equivalent to obj[-1, c(-1, -3), drop = FALSE] sb_rm(obj, i = \\(x)x>5) #> [1] 1 2 3 4 5 # above is equivalent to obj[!obj > 5]  #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb_rm(obj, \"a\") #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to obj[which(!names(obj) %in% \"a\")] sb_rm(obj, 1) # obj[-1] #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb_rm(obj, 1:2) #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # above is equivalent to obj[seq_len(length(obj))[-1:-2]] sb_rm(obj, is.numeric, drop = TRUE) #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" # above is equivalent to obj[[!sapply(obj, is.numeric)]] IF this returns a single element obj <- list(a = 1:10, b = letters[1:11], c = letters) sb_rm(obj, is.numeric) #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" #> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" #>  # above is equivalent to obj[!sapply(obj, is.numeric)] # this time singular brackets? # for recusive indexing, see sb_rec()  #############################################################################   # factors ====  obj <- factor(rep(letters[1:5], 2)) sb_rm(obj, lvl = \"a\") #> [1] b c d e b c d e #> Levels: a b c d e # above is equivalent to obj[which(!obj %in% \"a\")]  #############################################################################   # data.frame-like objects ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) print(obj) #>     a b  c d #> 1   1 a 11 a #> 2   2 b 12 b #> 3   3 c 13 c #> 4   4 d 14 d #> 5   5 e 15 e #> 6   6 f 16 f #> 7   7 g 17 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb_rm(obj, 1:3, 1:3) #>   d #> 1 d #> 2 e #> 3 f #> 4 g #> 5 h #> 6 i #> 7 j # above is equivalent to obj[-1:-3, -1:-3, drop = FALSE] sb_rm(obj, filter = ~ (a > 5) & (c < 19), vars = is.numeric) #>   b d #> 1 a a #> 2 b b #> 3 c c #> 4 d d #> 5 e e #> 6 i i #> 7 j j"},{"path":"https://tony-aw.github.io/subsets/reference/sb_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Modify Subsets of an Object By Reference — sb_set","title":"Method to Modify Subsets of an Object By Reference — sb_set","text":"S3 Method replace transform subset object REFERENCE.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Modify Subsets of an Object By Reference — sb_set","text":"","code":"sb_set(x, ...)  # S3 method for default sb_set(x, i, ..., rp, tf)  # S3 method for matrix sb_set(x, row = NULL, col = NULL, i = NULL, ..., rp, tf)  # S3 method for array sb_set(x, idx = NULL, dims = NULL, rcl = NULL, i = NULL, ..., rp, tf)  # S3 method for list sb_set(x, i, ..., rp, tf)  # S3 method for data.frame sb_set(x, row = NULL, col = NULL, filter = NULL, vars = NULL, ..., rp, tf)"},{"path":"https://tony-aw.github.io/subsets/reference/sb_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Modify Subsets of an Object By Reference — sb_set","text":"x see subsets_classes. ... arguments passed methods. , row, col, idx, dims, rcl, filter, vars See subsets_indx_args.  empty index selection returns original object unchanged. rp object somewhat type selected subset x, length selected subset x length 1. tf transformation function.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Modify Subsets of an Object By Reference — sb_set","text":"Returns: VOID. method modifies object REFERENCE. use assignment like x <- sb_set(x, ...). Since function returns void, just get NULL.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_set.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Modify Subsets of an Object By Reference — sb_set","text":"Transform Replace  Specifying argument tf transform subset. Specifying rp replace subset. One specify tf rp. either one set .  Note sb_set() method factors: intentional.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_set.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Method to Modify Subsets of an Object By Reference — sb_set","text":"Due way replacement transformation reference works, types (see typeof) coerced another type. Thus, example, following code:   gives c(rep(8, 8) 9:16) instead c(rep(8.5, 8), 9:16), x type integer, rp interpreted type integer also.","code":"x <- 1:16 sb_set(x, i = 1:8, rp = 8.5) x"},{"path":"https://tony-aw.github.io/subsets/reference/sb_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Modify Subsets of an Object By Reference — sb_set","text":"","code":"gen_mat <- function() {   obj <- matrix(1:16, ncol = 4)   colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\")   return(obj) }  # atomic objects ====  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_set(obj, 1:3, 1:3, rp = -1:-9) obj2 #>       a  b  c  a #> [1,] -1 -4 -7 13 #> [2,] -2 -5 -8 14 #> [3,] -3 -6 -9 15 #> [4,]  4  8 12 16 obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_set(obj, i = \\(x)x<=5, rp = -1:-5) obj2 #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_set(obj, col = \"a\", rp = cbind(-1:-4, -5:-8)) obj2 #>       a b  c  a #> [1,] -1 5  9 -5 #> [2,] -2 6 10 -6 #> [3,] -3 7 11 -7 #> [4,] -4 8 12 -8  obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_set(obj, 1:3, 1:3, tf = \\(x) -x) obj2 #>       a  b   c  a #> [1,] -1 -5  -9 13 #> [2,] -2 -6 -10 14 #> [3,] -3 -7 -11 15 #> [4,]  4  8  12 16 obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_set(obj, i = \\(x)x<=5, tf = \\(x) -x) obj2 #>       a  b  c  a #> [1,] -1 -5  9 13 #> [2,] -2  6 10 14 #> [3,] -3  7 11 15 #> [4,] -4  8 12 16 obj <- obj2 <- gen_mat() obj #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_set(obj, col = \"a\", tf = \\(x) -x) obj2 #>       a b  c   a #> [1,] -1 5  9 -13 #> [2,] -2 6 10 -14 #> [3,] -3 7 11 -15 #> [4,] -4 8 12 -16   gen_array <- function() {   array(1:64, c(4,4,3)) } obj <- gen_array() obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_set(obj, list(1:3, 1:2, c(1, 3)), 1:3, rp = -1:-12) obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -4    9   13 #> [2,]   -2   -5   10   14 #> [3,]   -3   -6   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -7  -10   41   45 #> [2,]   -8  -11   42   46 #> [3,]   -9  -12   43   47 #> [4,]   36   40   44   48 #>  obj <- gen_array() obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_set(obj, i = \\(x)x<=5, rp = -1:-5) obj #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   -1   -5    9   13 #> [2,]   -2    6   10   14 #> [3,]   -3    7   11   15 #> [4,]   -4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>"},{"path":"https://tony-aw.github.io/subsets/reference/sb_special.html","id":null,"dir":"Reference","previous_headings":"","what":"Specialized Sub-setting Functions — sb_special","title":"Specialized Sub-setting Functions — sb_special","text":"sb_a() function subsets extracts one attributes object.  sb_str() function subsets characters single string, replace subset characters single string subsets characters another string. cases, single string treated iterable vector, single character string single element. sb_str() function considerably faster equivalent operation base 'R' even 'stringi'.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_special.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specialized Sub-setting Functions — sb_special","text":"","code":"sb_str(str, ind, rp.str, rp.ind)  sb_a(x, a = NULL)"},{"path":"https://tony-aw.github.io/subsets/reference/sb_special.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specialized Sub-setting Functions — sb_special","text":"str single string. ind integer vector, giving positions string subset. rp.str, rp.ind similar str ind, respectively.  specified, sb_str() perform something like str[ind]  treating str iterable vector.  specified, sb_str() perform something like str[ind] <- rp.str[rp.ind]  treating str rp.str iterable vectors. x object character vector attribute names. NULL (default), attributes returned.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_special.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specialized Sub-setting Functions — sb_special","text":"sub-setted object.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_special.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specialized Sub-setting Functions — sb_special","text":"","code":"x <- matrix(1:10, ncol = 2) colnames(x) <- c(\"a\", \"b\") attr(x, \"test\") <- \"test\" sb_a(x, \"test\") #> $test #> [1] \"test\" #>  sb_a(x) #> $dim #> [1] 5 2 #>  #> $dimnames #> $dimnames[[1]] #> NULL #>  #> $dimnames[[2]] #> [1] \"a\" \"b\" #>  #>  #> $test #> [1] \"test\" #>    x <- \"hello\" sb_str(x, 5:1) # this gives \"olleh\" #> [1] \"olleh\" sb_str(x, c(1:5, 5)) # this gives \"helloo\" #> [1] \"helloo\" sb_str(x, c(2:5)) # this gives \"ello\" #> [1] \"ello\" sb_str(x, seq(1, 5, by = 2)) # this gives \"hlo\" #> [1] \"hlo\" sb_str(x, 1:4, \"world\", 1:4) # this gives \"worlo\" #> [1] \"worlo\""},{"path":"https://tony-aw.github.io/subsets/reference/sb_x.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"S3 Method extract, exchange, duplicate (.e. replicate indices x times) indices object.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_x.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"","code":"sb_x(x, ...)  # S3 method for default sb_x(x, i, ..., rat = FALSE)  # S3 method for matrix sb_x(x, row = NULL, col = NULL, i = NULL, ..., rat = FALSE)  # S3 method for array sb_x(x, idx = NULL, dims = NULL, rcl = NULL, i = NULL, ..., rat = FALSE)  # S3 method for factor sb_x(x, i = NULL, lvl = NULL, drop = FALSE, ..., rat = FALSE)  # S3 method for list sb_x(x, i, drop = FALSE, ..., rat = FALSE)  # S3 method for data.frame sb_x(x, row = NULL, col = NULL, filter = NULL, vars = NULL, ...)"},{"path":"https://tony-aw.github.io/subsets/reference/sb_x.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"x see subsets_classes. ... arguments passed methods. , lvl, row, col, idx, dims, rcl, filter, vars See subsets_indx_args.  Duplicates allowed, resulting duplicated indices.  empty index selection results empty object length 0. rat logical, indicating attributes returned sub-setted object. See Details section info. drop logical. factors: drop = TRUE, unused levels dropped, drop = FALSE dropped. lists: drop = TRUE, selecting single element give simplified result, like using [[]]. drop = FALSE, list always returned regardless number elements.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_x.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"Returns copy sub-setted object.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_x.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"One rat argument  [ - methods strip () attributes.  rat = FALSE, default behaviour preserved, compatibility special classes. fastest option.  rat = TRUE, attributes x missing sub-setting re-assigned x. Already existing attributes sub-setting overwritten.  rat argument data.frame-like object: attributes always preserved.  NOTE: following situations, rat argument ignored, attributes necessarily dropped: x list, drop = TRUE, single element selected. x matrix array, sub-setting done argument.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sb_x.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to Extract, Exchange, or Duplicate Subsets of an Object — sb_x","text":"","code":"# atomic objects ====  obj <- matrix(1:16, ncol = 4) colnames(obj) <- c(\"a\", \"b\", \"c\", \"a\") print(obj) #>      a b  c  a #> [1,] 1 5  9 13 #> [2,] 2 6 10 14 #> [3,] 3 7 11 15 #> [4,] 4 8 12 16 sb_x(obj, 1:3, 1:3) #>      a b  c #> [1,] 1 5  9 #> [2,] 2 6 10 #> [3,] 3 7 11 # above is equivalent to obj[1:3, 1:3, drop = FALSE] sb_x(obj, i = \\(x)x>5) #>  [1]  6  7  8  9 10 11 12 13 14 15 16 # above is equivalent to obj[obj > 5] sb_x(obj, col = c(\"a\", \"a\")) #>      a  a a  a #> [1,] 1 13 1 13 #> [2,] 2 14 2 14 #> [3,] 3 15 3 15 #> [4,] 4 16 4 16 # above is equivalent to obj[, lapply(c(\"a\", \"a\"), \\(i) which(colnames(obj) == i)) |> unlist()]  obj <- array(1:64, c(4,4,3)) print(obj) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   33   37   41   45 #> [2,]   34   38   42   46 #> [3,]   35   39   43   47 #> [4,]   36   40   44   48 #>  sb_x(obj, n(1:3, 1:2), c(1,3)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #>  sb_x(obj, rcl = n(1:3, NULL, 1:2)) #> , , 1 #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #>  # above 2 lines are equivalent to obj[1:3, , 1:2, drop = FALSE] sb_x(obj, i = \\(x)x>5) #>  [1]  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #> [26] 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 # above is equivalent to obj[obj > 5]  #############################################################################   # lists ====  obj <- list(a = 1:10, b = letters[1:11], c = 11:20) print(obj) #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  sb_x(obj, 1) # obj[1] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  sb_x(obj, 1, drop = TRUE) # obj[[1]] #>  [1]  1  2  3  4  5  6  7  8  9 10 sb_x(obj, 1:2) # obj[1:2] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $b #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" #>  sb_x(obj, is.numeric) # obj[sapply(obj, is.numeric)] #> $a #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> $c #>  [1] 11 12 13 14 15 16 17 18 19 20 #>  # for recursive indexing, see sb_rec()  #############################################################################   # factors ====  obj <- factor(rep(letters[1:5], 2)) sb_x(obj, lvl = c(\"a\", \"a\")) #> [1] a a a a #> Levels: a b c d e # above is equivalent to obj[lapply(c(\"a\", \"a\"), \\(i) which(obj == i)) |> unlist()]  #############################################################################   # data.frame-like objects ====  obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10])) print(obj) #>     a b  c d #> 1   1 a 11 a #> 2   2 b 12 b #> 3   3 c 13 c #> 4   4 d 14 d #> 5   5 e 15 e #> 6   6 f 16 f #> 7   7 g 17 g #> 8   8 h 18 h #> 9   9 i 19 i #> 10 10 j 20 j sb_x(obj, 1:3, 1:3) # obj[1:3, 1:3, drop = FALSE] #>   a b  c #> 1 1 a 11 #> 2 2 b 12 #> 3 3 c 13 sb_x(obj, filter = ~ (a > 5) & (c < 19), vars = is.numeric) #>   a  c #> 1 6 16 #> 2 7 17 #> 3 8 18"},{"path":"https://tony-aw.github.io/subsets/reference/seq_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Integer Sequence From a Range of Names — seq_names","title":"Generate Integer Sequence From a Range of Names — seq_names","text":"Generate integer sequence range names.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/seq_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Integer Sequence From a Range of Names — seq_names","text":"","code":"seq_names(names, start, end, inv = FALSE)"},{"path":"https://tony-aw.github.io/subsets/reference/seq_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Integer Sequence From a Range of Names — seq_names","text":"names character vector names.  Duplicate names, empty names, character vector length zero allowed. start name giving starting index sequence end name giving ending index sequence inv logical, TRUE, indices names EXCEPT names specified sequence given.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/seq_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Integer Sequence From a Range of Names — seq_names","text":"integer vector.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/seq_names.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Integer Sequence From a Range of Names — seq_names","text":"","code":"x <- data.frame(a = 1:10, b = letters[1:10], c = factor(letters[1:10]), d = -1:-10) ind <- seq_names(colnames(x), \"b\", \"d\") sb_x(x, col = ind) #>    b c   d #> 1  a a  -1 #> 2  b b  -2 #> 3  c c  -3 #> 4  d d  -4 #> 5  e e  -5 #> 6  f f  -6 #> 7  g g  -7 #> 8  h h  -8 #> 9  i i  -9 #> 10 j j -10"},{"path":"https://tony-aw.github.io/subsets/reference/seq_rec.html","id":null,"dir":"Reference","previous_headings":"","what":"Recursive Sequence Generator — seq_rec","title":"Recursive Sequence Generator — seq_rec","text":"recursive sequence generator. function essentially highly generalized version Fibonacci sequence generator. One can change initial values, window size, even window function used.  function assumes following sequence generated: sequence consists real numbers (.e. class integer class double). window size iterations. window function iterations. sequence grows vector length n achieved.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/seq_rec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recursive Sequence Generator — seq_rec","text":"","code":"seq_rec(inits = c(0, 1), n = 10L, f = sum)"},{"path":"https://tony-aw.github.io/subsets/reference/seq_rec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recursive Sequence Generator — seq_rec","text":"inits numeric (double integer) vector giving initial values.  numbers allowed, even negative /fractional numbers.  Note numbers given must give valid results passed function f().  IMPORTANT: length inits determines window size w.  regular Fibonacci, inits = 0:1, course means window size w = 2. n single integer, giving size numeric vector generate.  NOTE: must hold n larger equal window size w.  window size equal w = length(inits). f function used last w numbers generate next number sequence iteration.  must function takes input numeric vector, returns single numeric value.  regular Fibonacci sequence, either: f = sum,  (since window size 2) f = \\(x) x[2] + x[1]","code":""},{"path":"https://tony-aw.github.io/subsets/reference/seq_rec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recursive Sequence Generator — seq_rec","text":"sequence numbers.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/seq_rec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Recursive Sequence Generator — seq_rec","text":"default values arguments give first 10 numbers regular Fibonacci sequence.  See examples several number series created function.  function written C++ using Rcpp better performance.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/seq_rec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recursive Sequence Generator — seq_rec","text":"","code":"seq_rec() # by default gives Fibonacci numbers #>  [1]  0  1  1  2  3  5  8 13 21 34 seq_rec(0:3, 10L, sum) # a weird shifted version of Fibonacci #>  [1]   0   1   2   3   6  12  23  44  85 164 seq_rec(inits=2:1) # Lucas numbers #>  [1]  2  1  3  4  7 11 18 29 47 76 c(1, seq_rec(c(1, 2), f=prod)) # Multiplicative Fibonacci #>  [1]           1           1           2           2           4           8 #>  [7]          32         256        8192     2097152 17179869184 seq_rec(f=\\(x)2*x[2]+x[1]) # Pell numbers #>  [1]   0   1   2   5  12  29  70 169 408 985 seq_rec(inits = c(1, 0), f=\\(x)2*x[1]) # see https://oeis.org/A077957 #>  [1]  1  0  2  0  4  0  8  0 16  0 seq_rec(f=\\(x)x[2]+2*x[1]) # Jacobsthal numbers #>  [1]   0   1   1   3   5  11  21  43  85 171 seq_rec(c(1,1,1), f=\\(x)x[1] + x[2]) # Padovan sequence #>  [1] 1 1 1 2 2 3 4 5 7 9 seq_rec(c(3,0,2), f=\\(x)x[1] + x[2]) # Perrin numbers #>  [1]  3  0  2  3  2  5  5  7 10 12 seq_rec(c(0,1,3), f=\\(x)3*x[3] - 3*x[2] + x[1]) # Triangular numbers #>  [1]  0  1  3  6 10 15 21 28 36 45"},{"path":"https://tony-aw.github.io/subsets/reference/sub2ind.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"sub2coord() converts list integer subscripts integer matrix coordinates. coord2ind() converts integer matrix coordinates integer vector flat indices. ind2coord() converts integer vector flat indices integer matrix coordinates. coord2sub() converts integer matrix coordinates list integer subscripts. Note coord2sub() function performs simple (one might even say naive) conversion.  functions written memory-efficient.  coord2ind() thus opposite arrayInd, ind2coord merely convenient wrapper around arrayInd.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sub2ind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"","code":"sub2coord(sub, x.dim)  coord2sub(coord)  coord2ind(coord, x.dim, checks = TRUE)  ind2coord(ind, x.dim)"},{"path":"https://tony-aw.github.io/subsets/reference/sub2ind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"sub list integer subscripts.  first element list corresponds first dimension (rows), second element second dimensions (columns), etc.  length sub must equal length x.dim.  One give empty subscript; instead fill something like seq_len(dim(x)[margin]).  NOTE: coord2sub() function support duplicate subscripts. x.dim integer vector giving dimensions array question. .e. dim(x). coord integer matrix, giving coordinate indices (subscripts) convert.  row index, column dimension.  first columns corresponds first dimension, second column second dimensions, etc.  number columns coord must equal length x.dim. checks logical, indicating arguments checks performed.  Defaults TRUE. Can set FALSE minor speed improvements, recommended. ind integer vector, giving flat position indices convert.","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sub2ind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"sub2coord() ind2coord(): Returns integer matrix coordinates (properties described argument coord).  coord2ind(): Returns integer vector flat indices (properties described argument ind).  coord2sub(): Returns list integer subscripts (properties described argument sub)","code":""},{"path":"https://tony-aw.github.io/subsets/reference/sub2ind.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"S3 classes 'R' use standard Linear Algebraic convention, academic fields like Mathematics Statistics, following sense: vectors column vectors (.e. vertically aligned vectors); index counting starts 1; rows first dimension/subscript, columns second dimension/subscript, etc. Thus, orientation flat indices , example, 4 4 matrix, follows:   subscript [1,2] refers first row second column. 4 4 matrix, subscript [1,2] corresponds flat index 5.  functions described thus follow also convention.","code":"[,1] [,2] [,3] [,4]  [1,]    1    5    9   13  [2,]    2    6   10   14  [3,]    3    7   11   15  [4,]    4    8   12   16"},{"path":"https://tony-aw.github.io/subsets/reference/sub2ind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Subscripts to Coordinates, Coordinates to Flat Indices, and Vice-Versa — sub2ind","text":"","code":"x.dim <- c(1000, 10, 4, 4) x.len <- prod(x.dim) x <- array(1:x.len, x.dim) sub <- list(c(4,1), c(3,2), c(2,3), c(1,4)) coord <- sub2coord(sub, x.dim) print(coord) #>       V4 V3 V2 V1 #>  [1,]  4  3  2  1 #>  [2,]  1  3  2  1 #>  [3,]  4  2  2  1 #>  [4,]  1  2  2  1 #>  [5,]  4  3  3  1 #>  [6,]  1  3  3  1 #>  [7,]  4  2  3  1 #>  [8,]  1  2  3  1 #>  [9,]  4  3  2  4 #> [10,]  1  3  2  4 #> [11,]  4  2  2  4 #> [12,]  1  2  2  4 #> [13,]  4  3  3  4 #> [14,]  1  3  3  4 #> [15,]  4  2  3  4 #> [16,]  1  2  3  4 ind <- coord2ind(coord, x.dim) print(ind) #>  [1]  12004  12001  11004  11001  22004  22001  21004  21001 132004 132001 #> [11] 131004 131001 142004 142001 141004 141001 all(x[ind] == c(x[c(4,1), c(3,2), c(2,3), c(1,4)])) # TRUE #> [1] TRUE coord2 <- ind2coord(ind, x.dim) print(coord) #>       V4 V3 V2 V1 #>  [1,]  4  3  2  1 #>  [2,]  1  3  2  1 #>  [3,]  4  2  2  1 #>  [4,]  1  2  2  1 #>  [5,]  4  3  3  1 #>  [6,]  1  3  3  1 #>  [7,]  4  2  3  1 #>  [8,]  1  2  3  1 #>  [9,]  4  3  2  4 #> [10,]  1  3  2  4 #> [11,]  4  2  2  4 #> [12,]  1  2  2  4 #> [13,]  4  3  3  4 #> [14,]  1  3  3  4 #> [15,]  4  2  3  4 #> [16,]  1  2  3  4 all(coord == coord2) # TRUE #> [1] TRUE sub2 <- coord2sub(coord2) sapply(1:4, \\(i)sub2[[i]]==sub[[i]]) |> all() # TRUE #> [1] TRUE"}]
