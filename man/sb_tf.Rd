% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic_tf.R
\name{sb_tf}
\alias{sb_tf}
\alias{sb_tf.default}
\alias{sb_tf.list}
\alias{sb_tf.matrix}
\alias{sb_tf.array}
\alias{sb_tf.data.frame}
\title{Method to Transform a Subset of an Object}
\usage{
sb_tf(x, ...)

\method{sb_tf}{default}(x, i, ..., tf)

\method{sb_tf}{list}(x, i, ..., tf)

\method{sb_tf}{matrix}(x, row = NULL, col = NULL, i = NULL, ..., tf)

\method{sb_tf}{array}(x, idx = NULL, dims = NULL, i = NULL, ..., tf)

\method{sb_tf}{data.frame}(x, row = NULL, col = NULL, filter = NULL, vars = NULL, ..., tf)
}
\arguments{
\item{x}{a vector, vector-like object, factor, data.frame, data.frame-like object, or a list.}

\item{...}{further arguments passed to or from other methods.}

\item{i}{\code{sb_rp(x, i = i, tf = tf)} corresponds to \code{x[i] <- tf(x[i])}. \cr
Any of the following can be given here:
\itemize{
\item \code{NULL}, only for multi-dimensional objects or factors.
\code{NULL} results in the entire object being transformed.
\item a vector of length 0, in which case the original object is returned unchanged.
\item a strictly positive numeric vector with indices
(duplicates are NOT allowed).
\item logical vector (without \code{NA}s) of the same length as \code{x}
giving the indices to transform.
\item a character vector of index names
(duplicates are NOT allowed).
If an object has multiple indices with the given name,
all the values of the corresponding indices will be transformed.
\item function that returns a logical vector giving the element indices to select.
}}

\item{tf}{the transformation function to use.}

\item{row, col}{\code{sb(x, row, col, rp = rp)} corresponds to
\code{x[row, col] <- tf(x[row, col, drop = FALSE])}.\cr
Thus \code{row} = rows, \code{col} = columns. \cr
Any of the following can be given here:
\itemize{
\item \code{NULL} (default), which results in ALL of the indices this dimension being transformed.
\item a vector of length 0, in which case the original object is returned unchanged.
\item a strictly positive integer vector with dimension indices to transform
(duplicates are NOT allowed).
\item logical vector (without \code{NA}s) of the same length as the corresponding dimension size,
giving the indices of this dimension to transform.
\item a character vector of index names
(duplicates are NOT allowed).
If an object has multiple indices with the given name,
all the corresponding indices will be transformed.
}

NOTE: The arguments \code{row} and \code{col} will be ignored if \code{i} is specified.}

\item{idx, dims}{arguments to subset arrays:
\itemize{
\item \code{idx}: a list of indices.
\item \code{dims}: a integer vector of the same length as \code{idx},
giving the dimensions to which the indices given in \code{idx} correspond to.
}

The elements of \code{idx} follow the same rules as the rules for \code{row} and \code{col},
EXCEPT one should not fill in \code{NULL}. \cr
Thus \code{sb_tf(x, list(1:10, 1:4), c(1, 3), tf = tf)} is equivalent to
\code{x[1:10, , 1:4] <- tf(x[1:10, , 1:4, drop = FALSE])}. \cr
NOTE: The arguments \code{idx} and \code{dims} will be ignored if \code{i} is specified.}

\item{filter}{a one-sided formula with a single logical expression using the column names of the data.frame,
giving the condition which observations (rows)  should be transformed.}

\item{vars}{a function, giving the condition which variables (columns) should be transformed.}
}
\value{
A copy of the transformed object.
}
\description{
This is an S3 Method to transform a subset of an object. \cr
Note that there is no \code{sb_tf} method for factors.
This is intentional; use \link{relevel} instead.
}
\details{
One cannot specify \code{i} and \code{row}/\code{col}/\code{lvl}/\code{idx}/\code{dims} simultaneously.
It's either \code{i}, or the other arguments. \cr
\cr
One cannot specify \code{row} and \code{filter} simultaneously.
It's either one or the other. Similarly,
one cannot specify \code{col} and \code{vars} simultaneously. \cr
\cr
In the above cases it holds that if one set is specified, the other is set is ignored.
}
\examples{


# vector-like objects ====
obj <- matrix(1:16, ncol = 4)
colnames(obj) <- c("a", "b", "c", "a")
print(obj)
sb_tf(obj, 1:3, 1:3, tf = \(x)x^2)
# above is equivalent to obj[1:3, 1:3] <- (obj[1:3, 1:3, drop = FALSE])^2; obj
sb_tf(obj, i = \(x)x>5, tf = \(x)x^2)
# above is equivalent to obj[obj > 5] <- (obj[obj > 5])^2; obj
sb_tf(obj, col = "a", tf = \(x)x^2) 
# above is equivalent to obj[, colnames(obj) \%in\% "a"] <- (obj[, colnames(obj) \%in\% "a"])^2; obj

obj <- array(1:64, c(4,4,3))
print(obj)
sb_tf(obj, list(1:3, 1:2, c(1, 3)), 1:3, tf = \(x)x^2)
# above is equivalent to obj[1:3, 1:2, c(1, 3)] <- (obj[1:3, 1:2, c(1, 3), drop = FALSE])^2
sb_tf(obj, i = \(x)x<=5, tf = \(x)x^2)
# above is equivalent to obj[obj <= 5] <- (obj[obj <= 5])^2


# lists ====
obj <- list(a = 1:10, b = letters[1:11], c = 11:20)
print(obj)
sb_tf(obj, "a", tf =  \(x)x^2)
# above is equivalent to obj[names(obj) \%in\% "a"] <- (obj[names(obj) \%in\% "a"])^2
sb_tf(obj, is.numeric, tf = \(x)x^2)
# above is equivalent to obj[sapply(obj, is.numeric)] <- lapply(obj[sapply(obj, is.numeric)], \(x)x^2); obj


# data.frame-like objects ====
obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
print(obj)
sb_tf(obj, filter = ~ (a > 5) & (c < 19), vars = is.numeric, tf = \(x)x^2)


}
