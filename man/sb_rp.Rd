% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic_rp.R
\name{sb_rp}
\alias{sb_rp}
\alias{sb_rp.default}
\alias{sb_rp.list}
\alias{sb_rp.factor}
\alias{sb_rp.matrix}
\alias{sb_rp.array}
\alias{sb_rp.data.frame}
\title{Method to Replace Subsets of an Object With Different Values}
\usage{
sb_rp(x, ...)

\method{sb_rp}{default}(x, i, ..., rp)

\method{sb_rp}{list}(x, i, ..., rp)

\method{sb_rp}{factor}(x, i = NULL, lvl = NULL, ..., rp)

\method{sb_rp}{matrix}(x, row = NULL, col = NULL, i = NULL, ..., rp)

\method{sb_rp}{array}(x, idx = NULL, dims = NULL, i = NULL, ..., rp)

\method{sb_rp}{data.frame}(x, row = NULL, col = NULL, filter = NULL, vars = NULL, ..., rp)
}
\arguments{
\item{x}{a vector, vector-like object, factor, data.frame, data.frame-like object, or a list.}

\item{...}{further arguments passed to or from other methods.}

\item{i}{\code{sb_rp(x, i = i, rp = rp)} corresponds to \code{x[i] <- rp}. \cr
Any of the following can be given here:
\itemize{
\item \code{NULL}, only for multi-dimensional objects or factors.
\code{NULL} results in the entire object being transformed.
\item a vector of length 0, in which case the original object is returned unchanged.
\item a strictly positive numeric vector with indices
(duplicates are NOT allowed).
\item logical vector (without \code{NA}s) of the same length as \code{x}
giving the indices to transform.
\item a character vector of index names
(duplicates are NOT allowed).
If an object has multiple indices with the given name,
all the values of the corresponding indices will be transformed.
\item function that returns a logical vector giving the element indices to select.
}}

\item{rp}{an object of somewhat the same type as the selected subset of \code{x},
and the same same length as the selected subset of \code{x} or a length of 1.}

\item{lvl}{the levels of factor \code{x} to replace with the replacement vector \code{rp}.
Note that if argument \code{i} is specified instead of \code{lvl}, re-levelling does not occur,
and replacing subsets with new (i.e. unknown) levels will result in NA values.}

\item{row, col}{\code{sb(x, row, col, rp = rp)} corresponds to \code{x[row, col] <- rp}. \cr
Thus \code{row} = rows, \code{col} = columns. \cr
Any of the following can be given here:
\itemize{
\item \code{NULL} (default), which results in ALL of the indices this dimension being transformed.
\item a vector of length 0, in which case the original object is returned unchanged.
\item a strictly positive integer vector with dimension indices to transform
(duplicates are NOT allowed).
\item logical vector (without \code{NA}s) of the same length as the corresponding dimension size,
giving the indices of this dimension to transform.
\item a character vector of index names
(duplicates are NOT allowed).
If an object has multiple indices with the given name,
all the corresponding indices will be transformed.
}

NOTE: The arguments \code{row} and \code{col} will be ignored if \code{i} is specified.}

\item{idx, dims}{arguments to subset arrays:
\itemize{
\item \code{idx}: a list of indices.
\item \code{dims}: a integer vector of the same length as \code{idx},
giving the dimensions to which the indices given in \code{idx} correspond to.
}

The elements of \code{idx} follow the same rules as the rules for \code{row} and \code{col},
EXCEPT one should not fill in \code{NULL}. \cr
Thus \code{sb_rm(x, list(1:10, 1:4), c(1, 3), rp = rp)} is equivalent to
\code{x[1:10, , 1:4] <- rp}. \cr
NOTE: The arguments \code{idx} and \code{dims} will be ignored if \code{i} is specified.}

\item{filter}{a one-sided formula with a single logical expression using the column names of the data.frame,
giving the condition which observations (rows)  should be transformed.}

\item{vars}{a function, giving the condition which variables (columns) should be transformed.}
}
\value{
A copy of the object with replaced values.
}
\description{
This is an S3 Method to replace a subset of an object with different values.
}
\details{
One cannot specify \code{i} and \code{row}/\code{col}/\code{lvl}/\code{idx}/\code{dims} simultaneously.
It's either \code{i}, or the other arguments. \cr
\cr
One cannot specify \code{row} and \code{filter} simultaneously.
It's either one or the other. Similarly,
one cannot specify \code{col} and \code{vars} simultaneously. \cr
\cr
In the above cases it holds that if one set is specified, the other is set is ignored.
}
\examples{

# vector-like objects ====
obj <- matrix(1:16, ncol = 4)
colnames(obj) <- c("a", "b", "c", "a")
print(obj)
sb_rp(obj, 1:3, 1:3, rp = -1:-9)
# above is equivalent to  obj[1:3, 1:3] <- -1:-9; obj
sb_rp(obj, i = \(x)x<=5, rp = -1:-5)
# above is equivalent to  obj[obj <= 5] <- -1:-5; obj
sb_rp(obj, col = "a", rp = -1:-8)
# above is equivalent to  obj[, which(colnames(obj) \%in\% "a")] <- -1:-8; obj

obj <- array(1:64, c(4,4,3))
print(obj)
sb_rp(obj, list(1:3, 1:2, c(1, 3)), 1:3, rp = -1:-12)
# above is equivalent to obj[1:3, 1:2, c(1, 3)] <- -1:-12
sb_rp(obj, i = \(x)x<=5, rp = -1:-5)
# above is equivalent to obj[obj <= 5] <- -1:-5


# lists ====
obj <- list(a = 1:10, b = letters[1:11], c = 11:20)
print(obj)
sb_rp(obj, "a", rp = list(1))
# above is equivalent to  obj[["a"]] <- 1; obj
sb_rp(obj, is.numeric, rp = list(-1:-10, -11:-20))
# above is equivalent to  obj[which(sapply(obj, is.numeric))] <- list(-1:-10, -11:-20); obj


# data.frame-like objects ====
obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
print(obj)
sb_rp(obj, vars = is.numeric, rp = data.frame(-1:-10))




}
