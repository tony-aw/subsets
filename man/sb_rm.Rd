% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic_rm.R
\name{sb_rm}
\alias{sb_rm}
\alias{sb_rm.default}
\alias{sb_rm.factor}
\alias{sb_rm.list}
\alias{sb_rm.matrix}
\alias{sb_rm.array}
\alias{sb_rm.data.frame}
\title{Methods to remove Subsets from an object}
\usage{
sb_rm(x, ...)

\method{sb_rm}{default}(x, i, ...)

\method{sb_rm}{factor}(x, i = NULL, lvl = NULL, drop = FALSE, ...)

\method{sb_rm}{list}(x, i, drop = FALSE, ...)

\method{sb_rm}{matrix}(x, row = NULL, col = NULL, i = NULL, ...)

\method{sb_rm}{array}(x, idx = NULL, dims = NULL, i = NULL, ...)

\method{sb_rm}{data.frame}(x, row = NULL, col = NULL, filter = NULL, vars = NULL, ...)
}
\arguments{
\item{x}{vector, matrix, array, data.frame, or list}

\item{...}{further arguments passed to or from other methods.}

\item{i}{\code{sb_rm(x, i = i)} corresponds to \code{x[i]} - except \code{sb_rm()} removes indices. \cr
Any of the following can be given here:
\itemize{
\item \code{NULL}, only for multi-dimensional objects or factors.
\code{NULL} results in nothing being removed,
and the entire object is returned.
\item a vector of length 0, in which case nothing is removed,
and the entire object is returned.
\item a strictly positive integer vector with indices to remove
(duplicates are NOT allowed).
\item logical vector (without \code{NA}s) of the same length as \code{x} giving the indices to remove.
\item a character vector of index names to remove (duplicates are NOT allowed).
If an object has multiple indices with the given name(s),
all the corresponding indices will be removed.
\item a function that returns a logical vector giving the element indices to remove.
}}

\item{lvl}{names of the levels to remove.
Duplicates are NOT allowed.}

\item{drop}{logical.
\itemize{
\item For factors: If \code{TRUE}, unused levels are dropped, if \code{FALSE} they are not dropped.
\item For lists: is \code{TRUE}, selecting a single element will give the simplified result,
like using \verb{[[]]}. If \code{FALSE}, a list is always returned regardless of the number of elements.
}}

\item{row, col}{\code{sb(x, row, col)} corresponds to \code{x[row, col, drop = FALSE]} -
except \code{sb_rm()} removes indices. \cr
Thus \code{row} = rows, \code{col} = columns, \code{lyr} = layers (i.e. third dimension). \cr
Any of the following can be given here:
\itemize{
\item \code{NULL} (default), which results in ALL indices of this dimension being returned.
\item a vector of length 0, in which case nothing is removed
and the entire object is returned.
\item a strictly positive integer vector with indices
(duplicates are NOT allowed).
\item logical vector (without \code{NA}s) of the same length as the corresponding dimension size,
giving the indices of this dimension to remove.
\item a character vector of index names (duplicates are NOT allowed).
If an object has multiple indices with the given name(s),
all the corresponding indices will be removed.
}

NOTE: The arguments \code{row} and \code{col} will be ignored if \code{i} is specified.}

\item{idx, dims}{arguments to subset arrays:
\itemize{
\item \code{idx}: a list of indices.
\item \code{dims}: a integer vector of the same length as \code{idx},
giving the dimensions to which the indices given in \code{idx} correspond to.
}

The elements of \code{idx} follow the same rules as the rules for \code{row} and \code{col},
EXCEPT one should not fill in \code{NULL}. \cr
Thus \code{sb_rm(x, list(1:10, 1:4), c(1, 3))} is equivalent to \code{x[1:10, , 1:4, drop = FALSE]},
except \code{sb_rm()} removes indices. \cr
NOTE: The arguments \code{idx} and \code{dims} will be ignored if \code{i} is specified.}

\item{filter}{a one-sided formula with a single logical expression using the column names of the data.frame,
giving the condition which observations (rows) should be removed. \cr
For example: \cr
to \bold{remove} rows for which column \code{a > 2} and for which column \code{b != "a"},
specify the following formula: \cr
\code{~ (a > 2) & (b != "a")}}

\item{vars}{a function, giving the condition which variables (columns) should be removed.}
}
\value{
A copy of the sub-setted object.
}
\description{
This is an S3 Method to remove subsets from an object.
}
\details{
One cannot specify \code{i} and \code{row}/\code{col}/\code{lvl}/\code{idx}/\code{dims} simultaneously.
It's either \code{i}, or the other arguments. \cr
\cr
One cannot specify \code{row} and \code{filter} simultaneously.
It's either one or the other. Similarly,
one cannot specify \code{col} and \code{vars} simultaneously. \cr
\cr
In the above cases it holds that if one set is specified, the other is set is ignored.
}
\examples{

# vector-like objects ====
obj <- matrix(1:16, ncol = 4)
colnames(obj) <- c("a", "b", "c", "a")
print(obj)
sb_rm(obj, 1:3, 1:3)
# above is equivalent to  obj[-1:-3, -1:-3, drop = FALSE]
sb_rm(obj, i = \(x)x>5)
# above is equivalent to  obj[!obj > 5]
sb_rm(obj, col = "a")
# above is equivalent to  obj[, which(!colnames(obj) \%in\% "a")]

obj <- array(1:64, c(4,4,3))
print(obj)
sb_rm(obj, list(1, 1, c(1, 3)), 1:3)
# above is equivalent to obj[-1, -1, c(-1, -3), drop = FALSE]
sb_rm(obj, i = \(x)x>5)
# above is equivalent to obj[!obj > 5]


# lists ====
obj <- list(a = 1:10, b = letters[1:11], c = 11:20)
print(obj)
sb_rm(obj, "a")
# above is equivalent to obj[which(!names(obj) \%in\% "a")]
sb_rm(obj, 1) # obj[-1]
sb_rm(obj, 1:2)
# above is equivalent to obj[[seq_len(length(obj))[-1:-2]]]
sb_rm(obj, is.numeric, drop = TRUE)
# above is equivalent to obj[[!sapply(obj, is.numeric)]] IF this returns a single element
obj <- list(a = 1:10, b = letters[1:11], c = letters)
sb_rm(obj, is.numeric)
# above is equivalent to obj[!sapply(obj, is.numeric)] # this time singular brackets?
# for recusive indexing, see sb_rec()


# factors ====
obj <- factor(rep(letters[1:5], 2))
sb_rm(obj, lvl = "a")
# above is equivalent to obj[which(!obj \%in\% "a")]


# data.frame-like objects ====
obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
print(obj)
sb_rm(obj, 1:3, 1:3)
# above is equivalent to obj[-1:-3, -1:-3, drop = FALSE]
sb_rm(obj, filter = ~ (a > 5) & (c < 19), vars = is.numeric)



}
