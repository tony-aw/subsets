% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/special.R
\name{sb_special}
\alias{sb_special}
\alias{sb_rec}
\alias{sb_str}
\title{Specialized subsetting functions}
\usage{
sb_rec(lst, rec)

sb_str(str, ind)
}
\arguments{
\item{lst}{a list.}

\item{rec}{a vector of length \code{p},
such that \code{lst[[rec]]} is equivalent to \verb{lst[[rec[1]]...[[rec[p]]]},
providing all but the final indexing results in a list.}

\item{str}{a single string.}

\item{ind}{an integer vector, giving the positions of the string to subset.}
}
\value{
The subsetted object.
}
\description{
The \code{sb_rec()} function performs recursive subsetting of lists. \cr
The \code{sb_str()} function subsets a single string as-if it is an iterable object. \cr
}
\details{
The \code{sb_str()} function is several times faster
(the exact ratio depends on the string length)
than using something like the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{
x <- strsplit(x, "") |> unlist()
x <- paste0(x[ind])
paste(x, collapse = "")

}\if{html}{\out{</div>}}
}
\examples{
lst <- list(
  A = list(
    A = list(A = "AAA", B = "AAB"),
    B = list(A = "ABA", B = "ABB")
  ),
  B = list(
    A = list(A = "BAA", B = "BAB"),
    B = list(A = "BBA", B = "BBB")
  )
)
sb_rec(lst, c(1,2,2)) # this gives "ABB"
sb_rec(lst, c(2,2,1)) # this gives "BBA"

x <- "hello"
sb_str(x, 5:1) # this gives "olleh"
sb_str(x, c(1:5, 5)) # this gives "helloo"
sb_str(x, c(2:5)) # this gives "ello"
sb_str(x, seq(1, 5, by = 2)) # this gives "hlo"
substring(x, 1:5, 3:7) # "hel" "ell" "llo" "lo"  "o" 

}
