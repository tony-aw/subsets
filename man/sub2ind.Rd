% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sub2ind.R
\name{sub2ind}
\alias{sub2ind}
\alias{ind2sub}
\title{Convert Subscripts (Array Indices) to Flat Indices, and Vice-Versa.}
\usage{
sub2ind(coords, x.dim, x.len, checks = TRUE)

ind2sub(ind, x.dim, x.len)
}
\arguments{
\item{coords}{an integer matrix, giving the coordinate indices (subscripts) to convert. \cr
Each row is an index, and each column is the dimension. \cr
The number of columns of \code{coords} must be equal to the length of \code{x.dim}.}

\item{x.dim}{an integer vector giving the dimensions of the array in question. I.e. \code{dim(x)}.}

\item{x.len}{the length of the object, i.e. \code{length(x)}. This is needed to evaluate the dimensions.}

\item{checks}{logical, indicating if arguments checks should be performed. \cr
Defaults to \code{TRUE}. Can be set to \code{FALSE} for minor speed improvements, but not recommended.}

\item{ind}{an integer vector, giving the flat position indices to convert.}
}
\value{
The converted indices.
}
\description{
The \code{sub2ind()} function converts subscripts
(i.e. coordinate-like indices) to flat (1D) indices,
and the \code{ind2sub()} does the opposite. \cr
The \code{sub2ind()} is thus the opposite of \link{arrayInd},
and \code{ind2sub} is merely a convenient wrapper around \link{arrayInd}. \cr
\cr
Both functions are written to be memory-efficient.
}
\examples{
x.dim <- c(1000, 10, 4, 4)
x.len <- prod(x.dim)
x <- array(1:x.len, x.dim)
x[4,3,2, 1]
x[1,2,3,4]
coords <- rbind(c(4:1), 1:4)
ind <- sub2ind(coords, x.dim, x.len)
print(ind)
x[ind] == c(x[4, 3, 2, 1], x[1, 2, 3, 4]) # TRUE, TRUE
ind2sub(ind, x.dim, x.len)

}
