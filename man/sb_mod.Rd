% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic_mod.R
\name{sb_mod}
\alias{sb_mod}
\alias{sb_mod.default}
\alias{sb_mod.matrix}
\alias{sb_mod.array}
\alias{sb_mod.factor}
\alias{sb_mod.list}
\alias{sb_mod.data.frame}
\title{Method to Return a Copy of an Object With Modified Subsets}
\usage{
sb_mod(x, ...)

\method{sb_mod}{default}(x, i, ..., rp, tf)

\method{sb_mod}{matrix}(x, row = NULL, col = NULL, i = NULL, ..., rp, tf)

\method{sb_mod}{array}(x, idx = NULL, dims = NULL, rcl = NULL, i = NULL, ..., rp, tf)

\method{sb_mod}{factor}(x, i = NULL, lvl = NULL, ..., rp)

\method{sb_mod}{list}(x, i, ..., rp, tf)

\method{sb_mod}{data.frame}(
  x,
  row = NULL,
  col = NULL,
  filter = NULL,
  vars = NULL,
  coe = NULL,
  ...,
  rp,
  tf
)
}
\arguments{
\item{x}{see \link{subsets_classes}.}

\item{...}{further arguments passed to or from other methods.}

\item{i, lvl, row, col, idx, dims, rcl, filter, vars}{See \link{subsets_indx_args}. \cr
An empty index selection returns the original object unchanged. \cr}

\item{rp}{an object of somewhat the same type as the selected subset of \code{x},
and the same same length as the selected subset of \code{x} or a length of 1.}

\item{tf}{the transformation function.}

\item{coe}{For data.frame-like objects,
\code{sb_mod()} can only coerce whole columns, not subsets of columns. \cr
So it does not automatically coerce column types
when \code{row} or \code{filter} is also specified. \cr
Therefore, the user can specify a coercion function,
to be applied on the entirety of every column specified in \code{col} or \code{vars};
columns outside this subset are not affected. \cr
This coercion function is, of course, applied before replacement (\code{rp}) or transformation (\code{tf()}). \cr
By default, \code{coe = NULL} which means no columns are coercively transformed. \cr
See also the \code{Auto-Coercion Rules} and \code{Examples} sections below,
and also see \link{sb_coe}. \cr}
}
\value{
A copy of the object with replaced/transformed values.
}
\description{
This is an S3 Method to return a copy of an object with modified subsets.
}
\details{
\bold{Transform or Replace} \cr
Specifying argument \code{tf} will transform the subset. \cr
Specifying \code{rp} will replace the subset. \cr
One cannot specify both \code{tf} and \code{rp}. It's either one set or the other. \cr
Note that the \code{tf} argument is not available for factors: this is intentional. \cr
\cr
}
\section{Auto-Coercion Rules}{

\bold{Atomic objects} \cr
\ifelse{html}{\figure{auto-coercion-YES-darkgreen.svg}{options: alt='[auto-coercion: YES]'}}{\link[=subsets_classes]{auto-coercion: YES}} \cr
Atomic objects are automatically coerced to fit the replaced values. \cr
For example, replacing one or multiple values in an integer vector
(type \code{int})
with a decimal number
(type \code{dbl})
will coerce the entire vector to type \code{dbl}. \cr
\cr
\bold{Factors} \cr
\ifelse{html}{\figure{auto-coercion-NO-red.svg}{options: alt='[auto-coercion: NO]'}}{\link[=subsets_classes]{auto-coercion: NO}} \cr
Factors only accept values that are part of their levels,
and thus do NOT support coercion. \cr
Replacing a value with a new value not part of its levels,
will result in the replacement value being \code{NA}. \cr
\cr
\bold{Data.frame-like objects when replacing/transforming whole columns} \cr
\ifelse{html}{\figure{auto-coercion-depends-lightblue.svg}{options: alt='[auto-coercion: depends]'}}{\link[=subsets_classes]{auto-coercion: depends}} \cr
When replacing whole columns, so \code{row = NULL} and \code{filter = NULL},
coercion takes place according to the contents of the column. \cr
I.e. if the column is atomic, it follows the atomic rules,
if it is a factor, it follows the rules of the factor, etc. \cr
Note that coercion of columns needs \code{row = NULL} and \code{filter = NULL};
NO auto-coercion will take place when specifying something like \code{row = 1:nrow(x)}
(see next section). \cr
\cr
\bold{Data.frame-like objects when partially replacing/transforming columns} \cr
\ifelse{html}{\figure{auto-coercion-NO-red.svg}{options: alt='[auto-coercion: NO]'}}{\link[=subsets_classes]{auto-coercion: NO}} \cr
If rows are specified,
and thus not whole columns but parts of columns are replaced or transformed,
NO auto-coercion takes place. \cr
I.e.: replacing/transforming a value in an integer (\code{int}) column to become \code{1.5},
will NOT coerce the column to the decimal type (\code{dbl});
instead, the replacement value \code{1.5} is coerced to integer \code{1}. \cr
The \code{coe} argument allows the user to enforce coercion,
even if subsets of columns are replaced/transformed instead of whole columns. \cr
Specifically, the \code{coe} arguments allows the user to specify a coercive function
to be applied on the entirety of every column specified in \code{col} or \code{vars};
columns outside this subset are not affected. \cr
This coercion function is, of course, applied before replacement (\code{rp}) or transformation (\code{tf()}). \cr
\cr
\bold{Lists} \cr
\ifelse{html}{\figure{auto-coercion-depends-lightblue.svg}{options: alt='[auto-coercion: depends]'}}{\link[=subsets_classes]{auto-coercion: depends}} \cr
Lists themselves allow complete change of their elements,
since lists are merely pointers. \cr
However, a recursive subset of a list which itself is not a list,
follows the coercion rules of whatever class the recursive subset is. \cr
\cr \cr
}

\examples{

# vector-like objects ====
obj <- matrix(1:16, ncol = 4)
colnames(obj) <- c("a", "b", "c", "a")
print(obj)
rp <- -1:-9
sb_mod(obj, 1:3, 1:3, rp = rp)
# above is equivalent to  obj[1:3, 1:3] <- -1:-9; obj
sb_mod(obj, i = \(x)x<=5, rp = -1:-5)
# above is equivalent to  obj[obj <= 5] <- -1:-5; obj
sb_mod(obj, col = "a", rp = -1:-8)
# above is equivalent to  obj[, which(colnames(obj) \%in\% "a")] <- -1:-8; obj
sb_mod(obj, 1:3, 1:3, tf = \(x) -x)
# above is equivalent to  obj[1:3, 1:3] <- (-1 * obj[1:3, 1:3]); obj
sb_mod(obj, i = \(x)x<=5, tf = \(x) -x)
# above is equivalent to  obj[obj <= 5] <- (-1 * obj[obj <= 5]); obj

obj <- matrix(1:16, ncol = 4)
colnames(obj) <- c("a", "b", "c", "a")
print(obj)
sb_mod(obj, 1:3, 1:3, tf = \(x) -x)
# above is equivalent to  obj[1:3, 1:3] <- -1 * obj[1:3, 1:3]
sb_mod(obj, i = \(x)x<=5, tf = \(x) -x)
# above is equivalent to  obj[obj <= 5] <- -1:-5; obj
sb_mod(obj, col = "a", tf = \(x) -x)
# above is equivalent to  obj[, which(colnames(obj) \%in\% "a")] <- -1:-8; obj

obj <- array(1:64, c(4,4,3))
print(obj)
sb_mod(obj, list(1:3, 1:2), c(1,3), rp = -1:-24)
# above is equivalent to obj[1:3, , 1:2] <- -1:-24
sb_mod(obj, i = \(x)x<=5, rp = -1:-5)
# above is equivalent to obj[obj <= 5] <- -1:-5


# lists ====
obj <- list(a = 1:10, b = letters[1:11], c = 11:20)
print(obj)
sb_mod(obj, "a", rp = list(1L))
# above is equivalent to  obj[["a"]] <- 1L; obj
sb_mod(obj, is.numeric, rp = list(-1:-10, -11:-20))
# above is equivalent to  obj[which(sapply(obj, is.numeric))] <- list(-1:-10, -11:-20); obj


# data.frame-like objects ====
obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)

sb_mod(
  obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  tf = sqrt # WARNING: sqrt() results in `dbl`, but columns are `int`, so decimals lost
) 
sb_mod(
  obj, filter = ~ (a >= 2) & (c <= 17), vars = is.numeric,
  coe = as.double, tf = sqrt # SAFE: coercion performed
) 

obj <- data.frame(a = 1:10, b = letters[1:10], c = 11:20, d = factor(letters[1:10]))
str(obj) # notice that columns "a" and "c" are INTEGER (`int`)
sb_mod(
  obj, vars = is.numeric,
  tf = sqrt # SAFE: row=NULL & filter = NULL, so regular auto-coercion
)



}
